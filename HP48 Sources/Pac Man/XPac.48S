LIBRARY 999"PACMAN pour HP48, par C.de DINECHIN, V2.12 du 13/03/1993Version LightGraphiques par ETI"  COMMANDS    PAC AboutPAC ScoresPAC ResetPAC  LOCAL    PacCode View AboutCode PacScreen PacIntroScreen PacSprites    Tab1 Tab2 Tab3 Tab4 Tab5 Tab6 TabList    WaitKey  MESSAGES    [ "Unexpected screen addr" ]  CONFIG    PROG      999 ATTACH      PacIntroScreen View 1 WAIT    ENDCONTENT@ ************************************************************************@ 		The main program is not so small...@ ************************************************************************  PAC    PROG      PATH -> thePath <<      @ Il parait qu'il y a des problemes sinon...      HOME      @ Display the welcome Screen      PacScreen View      @ Check if TabList is initialized      IF PacTabList TYPE 5 <> THEN TabList 'PacTabList' STO END      @ Initialize all global variables      0 1 3       PacTabList 1 GET LIST-> DROP      SWAP EVAL NEWOB      -> Score Level Lives Speed PacTab      <<        DO          @ Wait for a Key          WaitKey          @ Execute the machine code part of PacMan          Speed PacSprites PacTab "GROB 144 241" STR->          PacCode          @ Get the score and Test it          5 ROLLD DROP2 DROP2          -> S          <<            @ Test if Pac Man was killed. Aoh            IF S #80000h AND #0h <> THEN              Lives 1 - 'Lives' STO            ELSE              @ Increment lives and level              Lives 1 + 'Lives' STO              Level 1 + 'Level' STO              IF Level PacTabList SIZE > THEN                1 'Level' STO              END              @ Get Table information in PacTabList              PacTabList Level GET LIST-> DROP              'Speed' STO EVAL NEWOB 'PacTab' STO                  END            @ Test if game was interrupted by user            IF S #40000h AND #0h <> THEN              0 'Lives' STO            END            @ Compute score            S #3FFFFh AND B->R 10 * Score + 'Score' STO            @ Display Score            PICT { #14d #18d } #103d #29d BLANK REPL            PICT { #16d #19d } "Score: " Score + 2 ->GROB              { #1d #0d } OVER GOR GOR            PICT { #16d #35d } "Lives: " Lives + 2 ->GROB              { #1d #0d } OVER GOR GOR          >>        UNTIL Lives 0 <= END        WaitKey        IF PacManScores TYPE 5 <> THEN ResetPAC END        @ Test if our score is in High Scores Table        1 7 FOR I          IF PacManScores I GET 2 GET Score <= THEN            "Bravo, vous avez unbon score! Votre nom?" { "" EXTERNAL #4358Ah } INPUT            Score 2 ->LIST 1 ->LIST            PacManScores 1 I OVER - SUB SWAP +            PacManScores I 7 SUB +            'PacManScores' STO 8 'I' STO          END        NEXT        ScoresPAC      >>      thePath EVAL >>    END@ ***********************************************************************@ 			Scores and High Scores Table@ ***********************************************************************  ResetPAC    PROG      PATH      HOME      { { "" 0 } } DUP + DUP + DUP + 'PacManScores' STO      EVAL    END  ScoresPAC    PROG      PATH -> thePath <<      HOME      IF PacManScores TYPE 5 <> THEN        ResetPAC      END      ERASE      PICT { #16d #0d } "Meilleurs Scores" 2 ->GROB        { #1d #0d } OVER GOR REPL      { #0d #0d } PVIEW      1 7 FOR I        PICT { #0d } I 8 * R->B +        PacManScores I GET 1 GET 2 ->GROB REPL        PICT PacManScores I GET 2 GET 2 ->GROB          #131d OVER SIZE DROP - I 8 * R->B 2 ->LIST SWAP REPL      NEXT      WaitKey      thePath EVAL >>    END  AboutPAC    PROG      PacIntroScreen View WaitKey TEXT CLLCD      "P A C M A N  v2.12 LIGHT.Ce programme est GRATUIT. Bon amusement." AboutCode DROP    END  View    PROG      PICT STO { #0 #0 } PVIEW    END  WaitKey    PROG      DO UNTIL KEY END DROP    END@ ****************************************************************************@ 			Table descriptions@ ****************************************************************************  Tab1    INCLUDE "TAB1.48S"  Tab2    INCLUDE "TAB2.48S"  Tab3    INCLUDE "TAB3.48S"  Tab4    INCLUDE "TAB4.48S"  Tab5    INCLUDE "TAB5.48S"  Tab6    INCLUDE "TAB6.48S"  TabList    {      { Tab1 #5678h }      { Tab2 #5678h }      { Tab3 #5678h }      { Tab4 #5678h }      { Tab5 #5678h }      { Tab6 #5678h }      { Tab1 #9ABCh }      { Tab3 #9ABCh }      { Tab2 #9ABCh }      { Tab4 #9ABCh }      { Tab6 #9ABCh }      { Tab5 #9ABCh }      { Tab2 #CDEFh }      { Tab5 #CDEFh }      { Tab3 #CDEFh }      { Tab4 #CDEFh }      { Tab6 #CDEFh }      { Tab1 #CDEFh }      { Tab5 #FDECh }      { Tab4 #FDECh }      { Tab3 #FDECh }      { Tab1 #FDECh }      { Tab2 #FDECh }      { Tab6 #FDECh }    }  PacSprites	INCLUDE "Grobs PAC"  PacScreenGROB 131 64 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF70FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF70BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA607555FFFFFFFFFFFFFFFFFFFFFFFFF55570BAAE0000000030000000000810000BAAE975530E700078000000000074F313045570BAA10940084C00000000084C4A9208AA6075D00523684A8568D894D82A2592005570BAA00C9210A94950B49420E3EA8100BA6075D0044A00A42940925220112E520055F9BAA0024D2014A6205A431011184200BA60755107CA1C0C652836C41C0B38C1085570BAA20000000000080000000000000CAA60755D000000000008000000000000075570BAAAFFFFFFFFFFFFFFFFFFFFFFFFFAAAE97555555555555555555555555555555570BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA607555555555555555555555555555555570BAAAFFFFFFFFFFFFFFFFFFFFFFFFFAAA6075551000000000000000000000008555F9BAAA1000870090008813200000008AAA607555100080008000C4A430000000855578BAAA10008025D12384A4249920008AAAE9755510008753905584A42C2A10008555FCBAAA1000801190758837242B00008AAA6C7555100080119015802424AA0000855571BAAA10008051905584A42CAA00008AAA6075551000872191258813241B0000855572BAAA1000000000000000040000008AAA687555100000000000000004000000855570BAAA1000000000000000000000008AAA6075551C90804004008087A8E9315195557CBAAA12A0004004008088A92441539AAA6475551289ACE4AC80A488A9240153955570BAAA128A924A6551DA88AAE50F559AAA607555128A844A25D19E88AA240155955570BAAA128A884A25509288AC2401599AAA60755512AA8A4A6551DA88AC244159955570BAAA1C9A84C4A490A487A8E931519AAA607555100000002000000000000000855570BAAA1000000020000000000000008AAA607555FFFFFFFFFFFFFFFFFFFFFFFFF55570BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA607555555555555555555555555555555570BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA6075555555555555555555555555555555F9BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA607555555555555555555555555555555570BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA607555555555555555555555555555555570BAAAFFFFFFFFFFFFFFFFFFFFFFFFFBAA60755D010000000000000000000040065570BAA301000000000000000010004008BAE27551017E4A86E1E25945C0339CC1305579BAA082925A898012D84B2194925A40AA6075D08392525F40625849E194924A706570BAA044925351208A58692094D25A00AA607551447E822EE1745059C123AC42705570BAA300120020000000000000000008BA60755D001200100000000000000000065570BAAAFFFFFFFFFFFFFFFFFFFFFFFFFBAA607555555555555555555555555555555570FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF70FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF70  PacIntroScreenGROB 131 64 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF70100000000000000000000000000000004010000000000000000000000000000000C410C0000000000000000000000000000C7010210000000000000000000000000EF7D7938000000000000000000000000FFBAA60150100EFF0000000000000008FF555555019210E100F000000000000EFFAAAAAAA6019C08300083000000000FF5555555555501500600000C0000008FFAAAAAAAAAAAA60930818700083000EF755555555555555501004048000440FFBAAAAAAAAAAAAAAAA601003020100C9F555555555555555555550108002010083BAAAAAAAAAAAAAAAAAAA60104001E100035555555555555555555550102001F1000E8AAAAAAAAAAAAAAAAAAA601C1001F000000555555555555557555550FB10027000000BAAAAAAAAAEBAFDAAAA605D000C3000000655555555534534555558B600000000000CAAAAAAAAAACA1BAAAF60550000008FFF14DFF555555F8D15FDF850B2000008FFFF78A00BAAAAAA8B2B3B03FE5300000FFFFFF9D93655F55D2D2DDE9250B10000CFFFFFF3B96AFA2FAA2F2BC49270510000FFFFFFF7594E9D945D663D149250B1000CFFFFFFFFA96E6BCDAA663FE49270D0000EFFFFFFFF793566265DE835E49370B0008FFFFFFFFFB18E462EAAE8376C91EFD000CFFFFFFFFF797776255DED3F890F707000EFFFFFFFFFB9A27ECDA68D0EFFFA605000FFFFFFFFFF79533E065DFFF55555DF7008FFFFFFFFFFB9B6CCFBAAAAAAAAAA605008FFFFFFFFFFF06DF755555555555550700CFFFFFFFFFFBFBAAAAAAAAFBAAAAA60D00EFFFFFFFFFF5555555555D0C55555D7700EFFFFFFFFFFAAAAAAAAAA200BAAAAE9500FFFFFFFFFFFD7555555551006555550700FFFFFFFFFFF68BAAAAAAA000CAAAA60518FFFFFFFFFF7106555555D0004555550708FFFFFFFFFFB10AAAAAAA60008AAAA60D18FFFFFFFFFFD20455555551008555558B08FFFFFFFFFFA00CAAAAAA60008AAAA60D20FFFF0F8FF7D204555555D2008555550B00EFF7040FFFA00CAAAAAA60008AAAA6A530EFF7080EFF5516555555510085555DCB10CFFF001EFFB14AAAAAAAA000CAAAAEA5B08FFF101CFF7795555555D2004555558B200FFF100CFFFAFAAAAAAAA900AAAAA615D00EFF300EFFF55555555553805555550B600CFFF00EFFFAAAAAAAAAAE2EAAAAA615D208FFF78FFF755555555555F755555DABA000FFFFFFFFFAAAAAAAAAAAAAAAAAA6955300EFFFFFFF755555555555555555550BAA008FFFFFFFAAAAAAAAAAAAAAAAAAA61555200EFFFFF75555555555555555555DFBAA0008FFFFFDAAAAAAAAAAAAAAAAAAA6F7553000CFFF365555555555555555555DFFFA60000CF78BAAAAAAAAAAAAAAAAAAA6FFFFD1000000755555555555555555555DFFFFF700000CAAAAAAAAAAAAAAAAAAAAA6FFFFFF300087555555555555555555555DFFFFFFF100FAAAAAAAAAAAAAAAAAAAAAA6FFFFFFFFFF5555555555555555555555554FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF71  PacCode    PROG      Check0	ASM**************************************************************************			PAC-MAN pour HP 48 SX				**************************************************************************	INCLUDE	"HARD.48S"	; Registres Hard de la 48	INCLUDE	"ROM.48S"	; Adresses ROM	INCLUDE	"RRAM.48S"	; Adresses RRAM**************************************************************************			Variables globales				**************************************************************************		RSRESETMONS_PosX	RS	3	; PositionMONS_PosY	RS	3MONS_Dir	RS	1	; DirectionMONS_Kind	RS	1	; Type de MonstreMONS_Status	RS	3	; Etat actuel du monstreMONS_Speed	RS	2	; Compteur de vitesseMONS_Size	RS	0		RSSET	$70C00	; Ecran texte jusqu'à 16 librairies.VARS_Start	RS	0	; Début des variables pacmanPAC_ToEat	RS	5	; Nombre de pastilles à manger.PAC_PosX	RS	3	; Position X du personnagePAC_PosY	RS	3	; Position Y du personnagePAC_Dir		RS	1	; Direction du personnage:PAC_NextDir	RS	1	; Direction demandée par les touchesPAC_Eating	RS	3	; Temps pendant lequel on mange les fantômesPAC_Speed	RS	2	; Compteur de vitesse PacManPAC_DirUp	equ	1	; Directions autorisees pour le personnagePAC_DirRight	equ	2PAC_DirDown	equ	3PAC_DirLeft	equ	4PAC_DirStand	equ	0BACK_GroundPtr	RS	5	; Pointeur vers description tableauBACK_Columns	RS	2	; Nombre de colonnes du tableauBACK_Width	RS	3	; Taille du tableau en pixelsBACK_Height	RS	3BACK_PacPtr	RS	5	; Pointeur sur l'objet où est le PacmanSCRN_LogBase	RS	5	; Adresses des ecrans logique ...SCRN_PhyBase	RS	5	; ... et physiqueSCRN_BckBase	RS	5	; Adresse du fond de l'écranSCRN_PosX	RS	3	; Position X de l'ecran. Utilisé pour l'offsetSCRN_PosY	RS	3	; Position Y de l'ecran. Utilisé pour l'offsetSCRN_RoundX	RS	3	; PosX & ~7SCRN_RoundY	RS	3	; PosY & ~7SCRN_LastX	RS	3	; Dernière position X de l'écranSCRN_LastY	RS	3	; Dernière position Y de l'écranSPRT_SpritesPtr	RS	5	; Adresse des dessins de spritesPAC_Score	RS	5	; Score fait dans ce tableau* UTILISES PAR LA ROUTINE DE SUIVIBEST_Dir1	RS	1	; Meilleure direction pour un monstreBEST_Dir2	RS	1BEST_Dir3	RS	1BEST_Dir4	RS	1TAR_PosX	RS	3	; Cible TAR_PosY	RS	3MONS_Info	RS	5	; Pointeur sur la description du monstre* VITESSE DES MONSTRESFOLLOW_Speed	RS	2FUGIT_Speed	RS	2PINKY_Speed	RS	2* POSITION DE RETOUR DES FANTOMESHOME_PosX	RS	6	; Position de retour des fantomes mangésHOME_Dir	RS	1	; Dummy (if not: Bug in initialisation)* Données concernant les monstresMONS_Number	RS	1MONS_Counter	RS	1MONS_Data	RS	MONS_Size*16VARS_End	RS	0	; Utilise pour savoir la longueur des variables**************************************************************************			Programme principal				*************************************************************************** Initialisation	GOSUBL	PAC_InitMAIN_Loop:* Déplacement utilisateur	GOSUBL	PAC_Key			; Teste les touches	D0=	PAC_PosX	GOSUBL	SPEED_Test	GONC	.pac	GOSUBL	PAC_Move		; Déplace le PACMAN* Affichages.pac	GOSUBL	PAC_ScreenPos		; Met l'écran en place	GOSUBL	SCRN_PutBackGround	; Affiche le fond	GOSUBL	PAC_Display		; Affiche le Pacman	LC	MONS_Data		; Initialise MONS_Info sur début liste	D0=	MONS_Info	DAT0=C	D0=	MONS_Number	C=DAT0(P)	D0=D0+1				; MONS_Counter	DAT0=C(P).monst	D0=	MONS_Info	A=DAT0	D0=A				; D0 Pointe sur les infos de monstre	GOSUBL	SPEED_Test		; Teste si monstre bouge	GONC	.disp	GOSUBL	GHOST_Move		; Déplace le fantôme.disp	GOSUBL	GHOST_Display		; Affiche le fantôme	GOSUBL	GHOST_Hit		; Teste ce que touche le fantôme	D0=	MONS_Info		; Fait pointer MONS_Info sur le suivant	A=DAT0	AD0EX	D0=D0+	MONS_Size	AD0EX	DAT0=A	D0=	MONS_Counter	A=DAT0(P)	A=A-1(P)	DAT0(P)=A	?A<>0(P)	GOYES	.monst	D0=	PAC_Eating	C=0	DAT0=C(X)	GOSUBL	SCRN_SwapScreen		; Permutation des écrans	D0=	PAC_ToEat	A=DAT0	?A=0	GOYES	.End	GOTO	MAIN_Loop* Fin du programme.End	D0=PAC_Score	C=DAT0	RSTK=C	GOSUBL	PAC_Exit	C=RSTK	A=C	P=4	GOVLNG	$0596D			; Met A comme binaire dans la pile**************************************************************************			Routines Graphiques de base			**************************************************************************SCRN_PutBackGround:* --------------------------------------------------------------------- ** 			Affichage du fond de l'ecran			** --------------------------------------------------------------------- ** On teste si le pacman a changé de case*  Si oui, on scrolle le fond comme nécéssaire, et on affiche la ligne*  ou la colonne manquante.* On copie ensuite le fond obtenu dans l'écran actuel.* Calcule les valeurs SCRN_RoundX et SCRN_RoundY	LC(6)	$FF8FF8		; Masque des positions	D0=SCRN_PosX	P=5	A=DAT0(WP)	A=A&C(WP)	D0=D0+6			; SCRN_RoundX	DAT0=A(WP)	P=0* TEST DU DEPLACEMENT VERS LA GAUCHE.left	D0=	SCRN_LastX	; Vérifie si les coordonnées X ont changé	A=DAT0(X)	D0=	D0-6		; SCRN_RoundX	C=DAT0(X)	?C>=A(X)		; Si on est allé à gauche	GOYES	.right		; non* On est allé à gauche.	LC(3)	8		; Indique un changement des coordonnées	A=A-C(X)	D0=D0+6			; SCRN_LastX	DAT0=A(X)	D0=	SCRN_BckBase	; Scrolle le fond vers la droite	A=DAT0	LC	36*72		; Pointe sur la fin de l'écran	A=A+C	D0=A	D1=A	D0=D0-2	GOSBVL	ROM_MoveUp	; Und ya scroll.	D0=	SCRN_LastX	GOSUBL	OBJECT_Under	; Récupère la position de colonne gauche	D0=	SCRN_BckBase	; A mettre en colonne gauche	C=DAT0	GOSUB	SCRN_FillColumn	; et remplit une colonne.	GOTO	.left		; Recommence (si plusieur colonnes...)* TEST DU DEPLACEMENT VERS LA DROITE.right	D0=	SCRN_LastX	; Vérifie si les coordonnées X ont changé	A=DAT0(X)	D0=	D0-6		; SCRN_RoundX	C=DAT0(X)	?C<=A(X)		; Si on est allé à droite	GOYES	.up		; non* On est allé à droite.	LC(3)	8		; Indique un changement des coordonnées	A=A+C(X)	D0=D0+6			; SCRN_LastX	DAT0=A(X)	D0=	SCRN_BckBase	; Scrolle le fond vers la gauche	A=DAT0	D0=A	D1=A	D0=D0+2	LC	36*72		; Taille à scroller	GOSBVL	ROM_MoveDn	D0=	SCRN_LastX	GOSUBL	OBJECT_Under	; Récupère la position de colonne droite	LC	34		; Pointe sur la colonne de droite	D=C	A=A+C	D0=	SCRN_BckBase	; A mettre en colonne droite	C=DAT0	C=C+D	GOSUB	SCRN_FillColumn	; et remplit une colonne.	GOTO	.right		; Recommence.* TEST DU DEPLACEMENT VERS LE HAUT.up	D0=	SCRN_LastY	; Vérifie si les coordonnées X ont changé	A=DAT0(X)	D0=	D0-6		; SCRN_RoundY	C=DAT0(X)	?C>=A(X)		; Si on est allé en haut	GOYES	.down		; non* On est allé vers le haut	LC(3)	8		; Indique un changement des coordonnées	A=A-C(X)	D0=D0+6			; SCRN_LastY	DAT0=A(X)	D0=	SCRN_BckBase	; Scrolle le fond vers le bas	A=DAT0	LC	36*64		; Pointe sur la fin de l'écran	A=A+C	D0=A	D=C	LC	36*8	A=A+C	D1=A	C=D			; Récupère la longueur à scroller	GOSBVL	ROM_MoveUp	; Und ya scroll.	D0=	SCRN_LastX	GOSUBL	OBJECT_Under	; Récupère la position de colonne gauche	D0=	SCRN_BckBase	; A mettre en première ligne	C=DAT0	GOSUB	SCRN_FillLine	; et remplit une ligne	GOTO	.up		; Recommence (si plusieur lignes...)* TEST DU DEPLACEMENT VERS LE BAS.down	D0=	SCRN_LastY	; Vérifie si les coordonnées X ont changé	A=DAT0(X)	D0=	D0-6		; SCRN_RoundY	C=DAT0(X)	?C<=A(X)		; Si on est allé à droite	GOYES	.copy		; non* On est allé vers le bas	LC(3)	8		; Indique un changement des coordonnées	A=A+C(X)	D0=D0+6			; SCRN_LastY	DAT0=A(X)	D0=	SCRN_BckBase	; Scrolle le fond vers le haut	A=DAT0	D1=A	LC	8*36	A=A+C	D0=A	LC	36*64	GOSBVL	ROM_MoveDn	D0=	SCRN_LastY	A=0	A=DAT0(X)	LC(3)	64	A=A+C(X)	GOSUBL	OBJECT_Under_GiveY	; Position Line		D0=	SCRN_BckBase	; A mettre en colonne droite	C=DAT0	D=C	LC	64*36		; Pointe sur le bas écran	C=C+D	GOSUB	SCRN_FillLine	; et remplit une ligne	GOTO	.down		; Recommence.* FIN: Copie dans l'écran courant.copy	D0=	SCRN_LogBase	A=DAT0	D0=D0+	SCRN_BckBase-SCRN_LogBase	C=DAT0	D1=A	D0=C	LC	36*72	GOVLNG	ROM_MoveDnSCRN_FillLine:* --------------------------------------------------------------------- ** 		Remplit une ligne du fond de l'écran			** --------------------------------------------------------------------- ** Entrée:*  A= Pointeur sur les données du tableau*  C= Pointeur sur l'écran	R0=A	R1=C	LC	0- 36*8 + 2	R3=C			; Offset à ajouter pour passer char suivant	LC(2)	18		; Nombre de colonnes à remplir	B=C(B)	LC	2		; Offset élément suivant	D=C	GOTO	SCRN_FillPatternsSCRN_FillColumn:* --------------------------------------------------------------------- ** 		Remplit une colonne du fond d'écran			** --------------------------------------------------------------------- ** Entrée:*  A= Pointeur sur les données du tableau*  C= Pointeur sur l'écran	R0=A	R1=C	C=0	R3=C			; Offset à ajouter pour passer char suivant	LC(2)	9		; Nombre de lignes à remplir	B=C(B)	D0=	BACK_Columns	C=0	C=DAT0(B)	C=C+C	D=CSCRN_FillPatterns:* --------------------------------------------------------------------- ** 		Remplit une série de patterns				** --------------------------------------------------------------------- ** Registres:*  R0= Données du tableau*  R1= Données écran*  R2= Sprites*  R3= Offset / Ligne suivante*  B = Nombre de patterns à copier.*  D = Offset / Tabelem suivant	D0=	SPRT_SpritesPtr	A=DAT0	R2=A			; Pointeur sur les sprites.PatternLoop:	A=R0	D0=A			; D0=pointeur donnees	C=0	C=DAT0(B)		; C=Objet	CD0EX	C=C+D	R0=C			; Stockage du nouveau pointeur objet	CD0EX	CSL			; Offset pour pointer sur le bon sprite	A=R2	A=A+C	D0=A			; D0 pointe sur la definition du sprite	A=R1	D1=A			; D1 pointe sur l'ecran	A=DAT0(W)	P=15	LC(1)	8		; C(S)=Compteur lignes	P=0	LC	36.ScreenCopy:	DAT1(B)=A	ASRC	ASRC	AD1EX	A=A+C	AD1EX	C=C-1(S)	?C<>0(S)	GOYES	.ScreenCopy	C=R3				; Pointe sur la position ecran suivante	AD1EX	A=A+C	R1=A	B=B-1(B)			; Boucle sur les colonnes	?B<>0(B)	GOYES	.PatternLoop	RTNSCRN_SwapScreen:* --------------------------------------------------------------------- ** 			Permutation des ecrans				** --------------------------------------------------------------------- ** La routine echange les variables SCRN_LogBase et SCRN_PhyBase.* Elle tient compte pour ecrire le pointeur ecran et les offsets des* variables de position SCRN_PosX et SCRN_PosY	A=0	D0=SCRN_PosY		; Calcul de l'offset ecran	A=DAT0(1)		; Lecture de la partie basse	LC(2)	7	A=A&C(B)	C=A	ASL			; * 16	C=C+C	A=A+C			; * 18	A=A+A			; * 36	B=A			; Mis en reserve	D0=SCRN_LogBase		; Pointeur ecran logique	A=DAT0	D0=D0+5			; D0=SCRN_PhyBase	C=DAT0	DAT0=A			; Permutation des ecrans	D0=D0-5	DAT0=C	D0=HARD_ScreenBase	; Pointeur physique ecran	A=A+B			; Plus decalage vertical	DAT0=A			; Stockage du pointeur ecran	D0=SCRN_PosX		; Offset horizontal	A=DAT0(1)	LC(2)	7	A=A&C(B)	?ABIT(2)=0	GOYES	.SmallPosX; Quand le decalage ecran est > 4	LC(1)	$C	A=A|C			; Grand decalage Hard	D0=HARD_ScreenShift	; Decalage hard	D1=HARD_ScreenWidth	C=0	DAT0=A(1)	DAT1=C(3)		; Largeur = 0	RTN; Quand le decalage ecran est < 4.SmallPosX:	LC(1)	3	A=A&C(B)	LC(1)	$8	A=A|C	D0=HARD_ScreenShift	D1=HARD_ScreenWidth	LC(3)	$002	DAT1=C(3)		; Largeur=2	DAT0=A(1)	RTNGHOST_Display:* --------------------------------------------------------------------- **			Affichage d'un des fantomes			** --------------------------------------------------------------------- ** Entrée:*  MONS_Info pointe sur les informations de description de sprite	D0=	MONS_Info	A=DAT0	D0=A	LC	20		; Numéro de sprite	D=C	D0=D0+	MONS_Dir	C=DAT0(1)	D=D+C(P)	D0=D0+	MONS_Status-MONS_Dir	C=DAT0(X)	?C=0(X)	GOYES	.std		; Si zéro: fantôme standard	C=C+1(X)		; Si -1, Yeux	?C=0(X)	GOYES	.eyes	A=C(X)	LC(3)	100	ACEX	?C>A(X)			; Teste si reste seulement 100 pour manger	GOYES	.noblnk	?CBIT(3)=0		; Si oui, clignote	GOYES	.std.noblnk	LC(1)	4		; Sinon, fantôme blanc	D=D+C(P)	GOTO	.std.eyes	LC(2)	21-12		; Fantôme "Yeux"	D=D-C(B).std	A=0			; Lecture des coordonnées dans A-B	D0=D0-	MONS_Status-MONS_PosY	A=DAT0(X)	B=A	D0=D0-	MONS_PosY-MONS_PosX	A=DAT0(X)	GOTO	SPRT_DisplayPAC_Display:* --------------------------------------------------------------------- **			Affichage  du personnage "Pacman"		** --------------------------------------------------------------------- *	D0=	PAC_Dir	C=0	C=DAT0(1)	D=C	LC(2)	16	D=D+C(B)	A=0	D0=PAC_PosY	A=DAT0(X)	B=A	D0=D0-3	A=DAT0(X)	C=A	C=C|B	?CBIT(2)=0	GOYES	SPRT_Display	LC(3)	16	D=CSPRT_Display:* --------------------------------------------------------------------- ** 			Affichage d'un sprite				** --------------------------------------------------------------------- ** Entree=*  A=Coordonnee X*  B=Coordonnee Y*  D=Numero du sprite	C=D			; Sauvegarde numéro de sprite	R0=C	LC	~7		; Charge le masque de décalages écrans	D=C	D0=SCRN_PosX		; Calcule le decalage par rapport a l'ecran	C=0	C=DAT0(X)		; Position X de l'ecran	C=C&D	A=A-C	D0=D0+3	C=DAT0(X)		; Position =Y de l'ecran	C=C&D	B=B-C	C=R0			; Récupère numéro de sprite	D=C	C=0	LC(1)	8		; Decalage pour les tests de clipping	A=A+C	B=B+C	LC(2)	131+15		; Si coordonnees hors ecran	?A>=C	RTNYES			; on ne trace rien	LC(2)	64+15	?B>=C	RTNYES	R0=A			; Reserve la position X	C=B			; Calcule l'addresse de debut de ligne Y*36+X/4	BSL			; Y * 16	C=C+C	B=B+C			; * 18	B=B+B			; * 36	A=A/2	A=A/2			; / 4	B=B+A	D0=SCRN_LogBase	A=DAT0			LC	8*36+2		; Enleve le clipping en haut et a gauche	A=A-C	A=A+B			; Ajoute l'offset ecran	D0=A			; D0=Addresse ecran	DSL			; Numero de sprite => Offset de sprite	D1=SPRT_SpritesPtr	A=DAT1	C=D	A=A+C	D1=A			; D1=definition du sprite	A=R0	LC(1)	3	A=A&C(P)	B=A(P)			; B=Compteur de decalages droit	P=15	LC(1)	8		; D(S)=Nombre de lignes	D=C(S)	P=0	LC	36		; D(A)=Offset ligne	D=C.SpriteLine:	A=0(X)	A=DAT1(B)	C=B(P).SpriteShift:			; Decalage du motif vers la droite	?C=0(P)	GOYES	.SpriteShifted	A=A+A(X)	C=C-1(P)	GOTO	.SpriteShift.SpriteShifted:	C=DAT0(X)		; Surimpression sur l'ecran	A=A|C(X)	DAT0=A(X)	CD0EX			; Décalage des pointeurs	C=C+D	CD0EX	D1=D1+2	D=D-1(S)	?D<>0(S)	GOYES	.SpriteLine	RTN**************************************************************************			Routines Specifiques a PAC			**************************************************************************PAC_Key:* --------------------------------------------------------------------- ** 			Deplacement du personnage			** --------------------------------------------------------------------- *	LC(4)	16			; Teste la touche BACK pour quitter	OUT=CS	GOSBVL	ROM_InputA	?ABIT(0)=0	GOYES	.Cont	D0=	PAC_ToEat		; Indique "Plus de pastilles à manger".	A=0	DAT0=A	D0=	PAC_Score		; Indique "Quitté à la main"	LC	$40000	A=DAT0	A=A|C	DAT0=A	RTNSC.Cont	LC(1)	4	OUT=CS	GOSBVL	ROM_InputA	D0=	PAC_NextDir	C=DAT0(P)	?ABIT(1)=0			; Teste la touche de droite	GOYES	.KeyRt	LC(1)	PAC_DirRight.KeyRt	?ABIT(3)=0			; Teste la touche de gauche	GOYES	.KeyLf	LC(1)	PAC_DirLeft.KeyLf	R0=C				; Sauvegarde la touche pressée	LC(1)	2	OUT=CS	GOSBVL	ROM_InputA		; Teste la touche du bas	C=R0	?ABIT(2)=0	GOYES	.KeyDn	LC(1)	PAC_DirDown.KeyDn	R0=C	LC(1)	8	OUT=CS	GOSBVL	ROM_InputA		; Teste la touche du haut	C=R0	?ABIT(2)=0	GOYES	.KeyUp	LC(1)	PAC_DirUp.KeyUp	D0=	PAC_NextDir	DAT0(1)=C	C=0	OUT=CS	RTNCCPAC_ScreenPos:* --------------------------------------------------------------------- ** 			Positionnement de l'écran			** --------------------------------------------------------------------- *	A=0	D0=	BACK_Width		; Lecture de la largeur d'écran	A=DAT0(X)	LC(3)	131	A=A-C(X)	B=A(X)	D0=	BACK_Height	A=DAT0(X)	LC(3)	64	A=A-C(X)	C=A(X)	D=C(X)	D0=	PAC_PosX		; Stockage des offsets écran	D1=	SCRN_PosX	A=0	A=DAT0(X)	LC(3)	64	?A>C(X)	GOYES	.KeepX1	A=C(X).KeepX1	A=A-C(X)	?A<=B(X)	GOYES	.KeepX2	A=B(X).KeepX2	DAT1(X)=A	B=A				; Offset BACK en quartets	B=B/2(A)	B=B/2(A)	B=B/2(A)	D1=D1+3				; Idem pour offset Y	D0=D0+3	A=DAT0(X)	LC(3)	28	?A>C(X)	GOYES	.KeepY1	A=C(X).KeepY1	A=A-C(X)	C=A	?C<=D(X)	GOYES	.KeepY2	C=D(X)	A=C(X).KeepY2	DAT1(X)=C	RTNCCPAC_Move:* --------------------------------------------------------------------- **			Gestion des déplacements du personnage		** --------------------------------------------------------------------- *	D0=	PAC_PosX	; Teste si changement de direction autorisé	A=DAT0(P)	D0=D0+3	C=DAT0(P)	A=A|C(P)	LC(1)	7	C=C&A(P)	?C(P)=0	GOYES	.Bound	GOTO	.Cont* PACMAN POSITIONNE SUR UNE CASE* Calcule la position "sous" le pacman..Bound	D0=	PAC_PosX	GOSUB	OBJECT_Under	D0=	BACK_PacPtr	DAT0=A* Avale les pastilles le cas échéant	GOSUB	PAC_Eat* Recherche de la direction	D0=	PAC_NextDir	; Copie de la direction si possible	C=DAT0(1)	R0=C	D=C(P)	GOSUB	PAC_DirOk	LC(2)	30	C=C-A(B)	GOC	.NoNext	C=R0	D0=PAC_Dir		; Direction OK: on copie	DAT0=C(P)	GOTO	.Cont.NoNext	D0=	PAC_Dir	C=DAT0(1)	D=C(P)	GOSUB	PAC_DirOk	LC(2)	30	C=C-A(B)	GONC	.Cont	D0=	PAC_Dir	C=0	DAT0(1)=C.Cont	D0=PAC_Dir		; Déplacement proprement dit	C=DAT0(P)	D=C(P)	D0=PAC_PosX		; Lecture des coordonnéesOBJECT_Move:* ---------------------------------------------------------------------	**		Déplacement d'un objet quelconque			** ---------------------------------------------------------------------	** D: Direction* D0: Pointeur sur les coordonnée:*  PosX[3] PosY[3] Dir[1]	D1=	BACK_Width	; Coordonnées limites du terrain	A=DAT0(X)		; Effectue le déplacement	D0=D0+3	C=DAT0(X)	D=D-1(P)		; Teste les quatre directions avec déplacement	?D(P)<>0	GOYES	.Up	C=C-1(X).Up	D=D-1(P)	?D(P)<>0	GOYES	.Right	A=A+1(X).Right	D=D-1(P)	?D(P)<>0	GOYES	.Down	C=C+1(X).Down	D=D-1(P)	?D(P)<>0	GOYES	.Left	A=A-1(X).Left	DAT0(X)=C			; Stocke les nouvelles coordonnées	D0=D0-3	D1=	BACK_Width		; Teste les dépassements hors jeu	C=DAT1(X)	C=C-9(X)	?A<C(X)	GOYES	.ok_rt	A=0(X)	A=A+1(X).ok_rt	?A<>0(X)	GOYES	.ok_lf	A=C(X).ok_lf	DAT0(X)=A	D0=D0+3	D1=D1+3	A=DAT0(X)	C=DAT1(X)	C=C-9(X)	?A<C(X)	GOYES	.ok_dn	A=0(X)	A=A+1(X).ok_dn	?A<>0(X)	GOYES	.ok_up	A=C(X).ok_up	DAT0(X)=A	RTNPAC_DirOk:* --------------------------------------------------------------------- **	Teste si la case pointée par la direction D est vide		** --------------------------------------------------------------------- *	D0=	BACK_PacPtr	A=DAT0OBJECT_DirOk:* --------------------------------------------------------------------- **	Teste si la case pointée par la direction D est vide		** --------------------------------------------------------------------- ** Entrée:*  R4 pointe sur ce qui est sous l'objet*  D0 pointe sur la direction à tester* Sortie:*  Carry set si contact dans la direction indiquée.	D0=	BACK_Columns	C=0	C=DAT0(B)	B=C	B=B+B	D=D-1(P)	D=D-1(P)		 ; Fait pointer A sur la bonne case.	GONC	.Up	A=A-B.Up	D=D-1(P)	GONC	.Right	A=A+1	A=A+1.Right	D=D-1(P)	GONC	.Down	A=A+B.Down	D=D-1(P)	GONC	.Left	A=A-1	A=A-1.Left	D0=A	A=DAT0(B)	LC(2)	32	C=C-A(B)	RTN			; Retourne C si valeur pointée sup à 32PAC_Eat:* --------------------------------------------------------------------- **		Mange les pastilles le cas échéant			** --------------------------------------------------------------------- *	D0=	BACK_PacPtr	A=DAT0	D0=A	A=DAT0(B)	LC(2)	4		; Limite des pastilles que l'on mange	?A>=C(B)	GOYES	.eaten	LC(2)	2	A=A-C(B)		; Mange la pastille.	GOC	.eaten		; Si déjà mangée	DAT0(B)=A		; Sinon, stocke.eaten	?A<>0(B)		; Teste si on fait du score	GOYES	.Score	D1=	PAC_Score	C=DAT1	C=C+1	DAT1=C	D1=	PAC_ToEat	; Nombre de pastilles à manger	C=DAT1	C=C-1	DAT1=C.Score	D0=	PAC_Eating	A=A-1(B)		; Teste si une pastille spéciale	?A<>0(B)	GOYES	.NoMiam	LC	400		; Si pastille spéciale, compteur "Miam"	DAT0(X)=C	D1=	PAC_Score	A=DAT1	A=A+C	DAT1=A	D1=	PAC_ToEat	C=DAT1	C=C-1	DAT1=C.NoMiam	C=DAT0(X)		; Décrémente le compteur "Miam" si nécéssaire	C=C-1(X)	GOC	.Danger	DAT0(X)=C* Réaffiche le fond..Danger	D0=	PAC_PosY	A=0	A=DAT0(X)	B=A(X)	D0=D0-3	A=DAT0(X)	D0=	BACK_PacPtr	C=DAT0	D0=C	C=DAT0(B)	D=0	D=C(B)SPRT_BackUpdate:* --------------------------------------------------------------------- **			Affiche un élément dans le fond			** --------------------------------------------------------------------- ** A= Coordonnée X (Arrondie au multiple de 8)* B= Coordonnée Y (Arrondie au multiple de 8)* D= Numéro de sprite.	C=D			; Sauvegarde numéro de sprite	R0=C	LC	~7		; Charge le masque de décalages écrans	A=A&C(X)	B=B&C(X)	D=C	D0=SCRN_PosX		; Calcule le decalage par rapport a l'ecran	C=0	C=DAT0(X)		; Position X de l'ecran	C=C&D	A=A-C	D0=D0+3	C=DAT0(X)		; Position =Y de l'ecran	C=C&D	B=B-C	C=R0			; Récupère numéro de sprite	D=C	C=0	LC(2)	131+8		; Si coordonnees hors ecran	?A>=C	RTNYES			; on ne trace rien	LC(2)	64+8	?B>=C	RTNYES	R0=A			; Reserve la position X	C=B			; Calcule l'addresse de debut de ligne Y*36+X/4	BSL			; Y * 16	C=C+C	B=B+C			; * 18	B=B+B			; * 36	A=A/2	A=A/2			; / 4	B=B+A	D0=SCRN_BckBase	A=DAT0	A=A+B			; Ajoute l'offset ecran	D0=A			; D0=Addresse ecran	DSL			; Numero de sprite => Offset de sprite	D1=SPRT_SpritesPtr	A=DAT1	C=D	A=A+C	D1=A			; D1=definition du sprite	LC	36		; Offset ligne	B=C	LC(1)	8		; C=Compteur de lignes	D=C(P).SpriteLine:	A=DAT1(B)	DAT0=A(B)	AD0EX	A=A+B	AD0EX	D1=D1+2	D=D-1(P)	?D<>0(P)	GOYES	.SpriteLine	RTN**************************************************************************			Déplacement des monstres			**************************************************************************OBJECT_Under:* --------------------------------------------------------------------- **		Rend un pointeur sur ce qui est sous un objet		** --------------------------------------------------------------------- ** Entrée:*  D0 pointe sur les coordonnées de l'objet (2x3)* Sortie:*  A pointe sur l'octet sur lequel est l'objet	D0=D0+3				; Pointe sur Y	A=0	A=DAT0(X).GiveY	A=A/2(A)	A=A/2(A)	D1=	BACK_Columns		; Largeur du tableau	C=0	C=DAT1(B)	GOSBVL	ROM_B_is_AxC	D0=D0-3	A=0	A=DAT0(X)	A=A/2(A)	A=A/2(A)	B=B+A	D1=	BACK_GroundPtr	A=DAT1	A=A+B	RTNDIR_Choose:* --------------------------------------------------------------------- **		Choix de direction pour atteindre une cible		** --------------------------------------------------------------------- ** Entrée:*  MONS_Info pointe sur MONS_PosX, MONS_PosY, MONS_Dir*  TAR_PosX, TAR_PosY		: Cible à atteindre* Sortie:*  BEST_Dir1:	Meilleure direction possible*  BEST_Dir2:	Seconde meilleure direction.*  BEST_Dir3:   Troisième meilleure direction*  BEST_Dir4:   Plus mauvaise direction	D0=	MONS_Info	; Lecture de la direction	A=DAT0	D0=A	D0=D0+6			; Pointe sur la direction	C=DAT0(P)	D=C(P)	?CBIT(0)=1		; Teste si direction est horizontale	GOYES	.vert	GOTO	.horiz* CAS OU LA DIRECTION ACTUELLE EST VERTICALE.vert	D0=D0-6	A=DAT0(X)		; A=MONS_PosX	D1=	TAR_PosX	C=DAT1(X)		; C=TAR_PosX	?A=C(X)			; Cas particulier pour l'égalité.	GOYES	.equal	B=C(X)	C=D(P)			; Récupère la direction	D1=	BEST_Dir2	; La seconde meilleure direction est l'actuelle	DAT1(P)=C	LC(1)	PAC_DirRight	?A<B(X)			; Si MONS<TAR	GOYES	.right	LC(1)	PAC_DirLeft.right	D1=D1-1	DAT1(P)=C.comp	D0=	BEST_Dir1	; Etablit les directions 3 et 4 par complément	C=DAT0(P)	D=C(P)	D=D+1(P)	LC(1)	3	C=C&D(P)	C=C+1(P)	D0=D0+2	DAT0=C(P)	D0=D0-1	C=DAT0(P)	D=C(P)	D=D+1(P)	LC(1)	3	C=C&D(P)	C=C+1(P)	D0=D0+2	DAT0=C(P)	RTN* Si égalité sur la coordonnée testée..equal	D1=	BEST_Dir1	; Si égalité, le meilleur est la dir. actuelle	C=D(P)	DAT1=C(P)	LC(1)	3	DCEX(P)	C=C&D(P)	C=C+1(P)	D1=D1+1	DAT1=C(P)		; Le second est la direction perpendiculaire	C=C&D(P)		; Direction 3	C=C+1(P)	D1=D1+2	DAT1=C(P)	C=C&D(P)		; Direction 4	C=C+1(P)	D1=D1-1	DAT1=C(P)	RTN* CAS OU LA DIRECTION ACTUELLE EST HORIZONTALE.horiz	D0=D0-3	A=DAT0(X)		; A=MONS_PosY	D1=	TAR_PosY	C=DAT1(X)		; C=TAR_PosY	?A=C(X)			; Si égales, cas particulier	GOYES	.equal	B=C(X)	C=D(P)			; Récupère la direction	D1=	BEST_Dir2	; La seconde meilleure direction est l'actuelle	DAT1(P)=C	LC(1)	PAC_DirDown	?A<B(X)			; Si MONS<TAR	GOYES	.down	LC(1)	PAC_DirUp.down	D1=D1-1	DAT1(P)=C	GOTO	.comp		; effectue le complément.GHOST_Move:* --------------------------------------------------------------------- **			Déplacement d'un fantôme			** --------------------------------------------------------------------- ** D0 pointe sur MONS_Data (stocké dans MONS_Info)* MONS_Kind indique le type de monstre	D1=	PAC_PosX		; Utilise le Pac Man comme cible	P=5	A=DAT1(WP)	D1=	TAR_PosX	DAT1(WP)=A	P=0	AD0EX	D0=A	D1=A				; D1 pointe sur les données du monstre	D1=D1+	MONS_Kind		; Teste le type de monstre	A=DAT1(P)	?A<>0(P)	GOYES	.no1	LC	$04321.no1	A=A-1(P)	?A<>0(P)	GOYES	.no2	LC	$04123.no2	A=A-1(P)	?A<>0(P)	GOYES	.no3	LC	$04231.no3	D1=D1+	MONS_Status-MONS_Kind	; Vérifie si peut être mangé	A=DAT1(X)	?A=0(X)	GOYES	.nosup	A=A+1(X)	?A=0(X)	GOYES	.eyes	LC	$4123		; Si poursuivi, s'enfuit...	GOTO	.nosup.eyes	D1=	HOME_PosX	; Si les yeux, utilise la maison comme cible	P=5	A=DAT1(WP)	D1=	TAR_PosX	DAT1(WP)=A	P=0	LC	$04321		; Et devient "poursuivant".nosup:MONS_Move:* --------------------------------------------------------------------- **		Déplacement pour un fantôme				** --------------------------------------------------------------------- ** Deplacement direct (sans tenir compte du pacman)* D0 pointe sur MONS_PosX, MONS_PosY, MONS_Dir (stocké dans MONS_Info)* TAR_PosX, TAR_PosY indiquent le point à atteindre.* C indique le type de suivi demandé (ordre de test des directions)	R3=C			; Récupère l'ordre de test.	AD0EX			; Stocke MONS_Info	D0=	MONS_Info	; Pointeur sur les infos de monstre	DAT0=A	D0=A	A=DAT0(P)	D0=D0+3	C=DAT0(P)	A=A|C(P)	LC(1)	7	C=C&A(P)	?C=0(P)	GOYES	.case	D0=D0+3			; pointe sur la direction	GOTO	.suite* Ici, on est sur une case "vraie". Teste le déplacement.case	D0=	MONS_Info	A=	DAT0	D0=A	GOSUB	OBJECT_Under	R4=A	GOSUB	DIR_Choose	; Initialise les directions à prendre..loop	C=R3	?C=0(P)	GOYES	.closed		; Fantôme bloqué	B=0	B=C(P)	CSR			; Lit la direction suivante	R3=C	LC	BEST_Dir1-1	; Teste la direction stockée dans R3	C=C+B			; C pointe sur la direction à tester	D0=C	C=DAT0(P)	D=C(P)	A=R4	GOSUB	OBJECT_DirOk	; Teste si la direction est bonne	GOC	.loop		; Si oui, la choisit.choose	LC(1)	5	C=C+D(P).closed	D0=	MONS_Info	; Stocke l'information	A=DAT0	D0=A	D0=D0+6	DAT0(P)=C* DEPLACEMENT DU SPRITE.suite	C=DAT0(P)	D=C(P)	D0=D0-6	GOLONG	OBJECT_Move**************************************************************************			Test de la vitesse				**************************************************************************SPEED_Test:	AD0EX	D1=A	AD0EX	D1=D1+	MONS_Speed	A=DAT1(P)		; Lit la vitesse	A=A+1(P)		; Si vitesse = 15, déplacement automatique	RTNC	D1=D1+1	C=DAT1(P)	C=C+A(P)		; Fait un débordement de capacité.	DAT1(P)=C	RTN**************************************************************************	Teste le comportement du fantôme (attaque, fuite,...		**************************************************************************GHOST_Hit:	D0=	MONS_Info	A=DAT0	D0=A	D0=D0+	MONS_Status	D1=	PAC_Eating	A=DAT1(X)	?A=0(X)	GOYES	.no_pac	C=DAT0(X)		; Teste si le monstre est en état "Yeux"	C=C+1(X)	GOC	.no_pac		; Si oui: ne change pas son état	DAT0=A(X)		; Indique que le monstre peut se faire manger	D0=D0-2			; Direction du monstre	A=DAT0(P)		; Le monstre prend la direction opposée 	A=A+1(P)	LC(1)	3	A=A&C(P)	A=A+1(P)	DAT0=A(P)	D0=D0+2.no_pac	A=DAT0(X)	?A=0(X)	GOYES	.attq	A=A+1(X)	?A<>0(X)	GOYES	.noeyes	GOTO	.eyes.noeyes	A=A-1(X)		; Si poursuivi, décrémente compteur	A=A-1(X)	DAT0(X)=A.attq	D0=D0-	MONS_Status	D1=	PAC_PosX	A=DAT0(X)		; Teste si coordonnée X OK	C=DAT1(X)	A=A-C(X)	LC(3)	4	A=A+C(X)	LC(2)	8	A=A-C(X)	RTNNC			; Si pas touché, exit	D0=D0+	MONS_PosY	; Teste coordonnée Y	D1=D1+	MONS_PosY	A=DAT0(X)	C=DAT1(X)	A=A-C(X)	LC(3)	4	A=A+C(X)	LC(2)	8	A=A-C(X)	RTNNC				D0=D0+	MONS_Status-MONS_PosY	; teste si mangé ou non	C=DAT0(X)	?C=0(X)	GOYES	.dead	LC(3)	$FFF		; Si mangé, indique "EYES"	DAT0(X)=C	D1=	PAC_Score	; et ajoute 100 au score	A=DAT1	LC	100	A=A+C	DAT1=A	RTN.dead	D0=	PAC_ToEat		; Indique "Fin de partie"	C=0	DAT0=C	D0=	PAC_Score		; Indique "Mangé par un fantôme"	A=DAT0	LC	$80000	A=A|C	DAT0=A	RTN.eyes	D0=D0-	MONS_Status		; Pointe sur coordonnée	P=5	A=DAT0(WP)	D1=	HOME_PosX	C=DAT1(WP)	?A=C(WP)			; Si de retour à la maison	GOYES	.home	P=0	RTN	.home	P=0	D0=D0+	MONS_Status	C=0(X)	DAT0=C(X)	RTNFATAL_ERROR	C=RSTK			; Si impossible de jouer...		GOSBVL	ROM_LoadRegs		LC	$3E701		A=C		GOVLNG	ROM_Error	; Affiche l'erreurPAC_Init:**************************************************************************			Initialisation du Jeu				**************************************************************************		GOSBVL	ROM_SaveRegs	; Sauvegarde les registres		D0=RRAM_GROBStack	; Teste si l'écran peut accueillir		A=DAT0			; les variables du programme		LC	20		A=A+C				LC	VARS_Start		?C<A(A)			; Dépassement au début de l'écran		GOYES	FATAL_ERROR				LC	2196		; Taille de l'écran		A=A+C				LC	VARS_End	; Dépassement à la fin de l'écran		?C>A(A)		GOYES	FATAL_ERROR		* COUPURE DES INTERRUPTIONS CLAVIER	ST(15)=0* INITIALISATION DE L'ECRAN* Trois écrans de 64 lignes, séparés par 8 lignes (clipping), avec 8 lignes* au dessus et 8 lignes au dessous. Largeur = 36 quartets.* Stockés dans un GROB au premier niveau de la pile	LC(3)	63	D0=	HARD_ScreenHeight	; Passe en "Full Screen"	DAT0=C(X)	A=DAT1				; Lit le GROB dans la pile	LC	8*36+20+2		; Pointe sur le début de l'écran 1	A=A+C	ABIT(0)=0			; S'assure que débute sur octet	D0=	SCRN_LogBase		; Initialise Logbase	DAT0=A	D0=D0+5	LC	80*36			; Pointe sur le deuxième écran.	A=A+C	DAT0=A				; Initialise PhyBase	D0=D0+5	A=A+C				; Pointe sur l'écran de fond	DAT0=A* INITIALISATION DU FOND	D1=D1+5			; Ancien niveau 1: Description du fond	A=DAT1	LC	20		; Récupération d'un objet graphique	A=A+C	D0=BACK_GroundPtr	DAT0=A			; BACK_GroundPtr	AD0EX	D0=D0-5			; Largeur du graphique	C=DAT0	D0=D0-5	A=DAT0			; Hauteur du graphique	A=A+A	A=A+A	A=A+A	D0=BACK_Height	DAT0(X)=A	D0=D0-	BACK_Height-BACK_Width	DAT0(X)=C	C=C/2	C=C/2	C=C/2	D0=D0-	BACK_Width-BACK_Columns	DAT0(B)=C* INITIALISATION DE LA LISTE DES SPRITES	D1=D1+5			; Niveau 2: Liste des sprites	A=DAT1	LC	20	A=A+C	D0=	SPRT_SpritesPtr	DAT0=A			; SPRT_SritesPtr* INITIALISATION DES VITESSES	D1=D1+5	A=DAT1	D0=A	D0=D0+10	A=DAT0	D0=	PAC_Speed	DAT0=A(P)	ASR	D0=	FOLLOW_Speed	; D0= FOLLOW_Speed	DAT0=A(P)	ASR	D0=D0+2			; D0= FUGIT_Speed	DAT0=A(P)	ASR	D0=D0+2			; D0= PINKY_Speed	DAT0=A(P)* INITIALISATION PACMAN	D0=	PAC_Eating	; Le pacman ne mange rien	C=0	DAT0=C(X)	D0=	PAC_Score	DAT0=C			; Score = 0	D0=	PAC_Dir		; Direction = "Standing"	DAT0=C(B)* INITIALISATION DU TABLEAU	D0=	MONS_Info	LC	MONS_Data	DAT0=C	C=0(P)	D0=	MONS_Number	DAT0=C(P)	D0=	BACK_GroundPtr	; Pointeur vers le tableau	A=DAT0	D0=A	A=0			; Nombre de pastilles à manger Initialisé à 0	R0=A	R1=A			; Coordonnée X	R2=A			; Coordonnée Y	D1=	BACK_Height	; Nombre de lignes dans D(X)	C=DAT1(X)	C=C/2(X)	C=C/2(X)	C=C/2(X)	D=C(X).line	D1=	BACK_Columns	;	A=DAT1(B)		; Nombre de colonnes dans B(B)	B=A(B).column	A=DAT0(B)		; Lecture du tableau et comptage de ce qui	LC(2)	2		; reste à manger	?A<C(B)			; Si pastille mangée, ne compte pas	GOYES	.nopast	LC(1)	4		; Si pas pastille, ne compte pas	?A>=C(B)	GOYES	.nopast	C=R0			; Ajoute une pastille au décompte	C=C+1	R0=C.nopast	LC(2)	$08		; Teste si position de "retour"	D1=	HOME_PosX	?A=C(B)	GOYES	.newpos		LC(2)	$30		; Si "position de départ PAC MAN", stocke	D1=	PAC_PosX	; Initialisation position de départ	?A<>C(B)	GOYES	.nopac.newpos	C=R1	DAT1=C(X)	D1=D1+3			; MONS_PosX	C=R2	DAT1=C(X)	D1=D1+3	LC(1)	1		; MONS_Dir	DAT1(P)=C.no_pos	GOTO	.next.nopac	?A<C(B)			; Est ce un point de départ de monstre?	GOYES	.no_pos	LC(1)	$3	?A>C(B)	GOYES	.no_pos	D1=	MONS_Info	C=DAT1	D1=C				; D1 Pointe sur le bon monstre	D1=D1+	MONS_Kind	A=A-1(P)	DAT1=A(P)			; Type de monstre (0-2)	D1=D1+	MONS_Status-MONS_Kind	; MONS_Stat = 0	C=0	DAT1=C(X)	C=A(P)				; Type *2 pour pointer sur la vitesse	C=C+C	A=C	LC	FOLLOW_Speed	A=A+C	AD1EX				; D1= Vitesse de ce monstre	C=DAT1(P)	AD1EX	D1=D1+	MONS_Speed-MONS_Status	DAT1=C(P)			; Stockée dans MONS_Speed	D1=D1-	MONS_Speed-MONS_PosX	C=R1	DAT1=C(X)	D1=D1+	MONS_PosY-MONS_PosX	C=R2	DAT1=C(X)	D1=D1+	MONS_Dir-MONS_PosY	LC(1)	1			; Direction	DAT1(P)=C	D1=	MONS_Info		; Monstre suivant	A=DAT1	LC	MONS_Size	A=A+C	DAT1=A	D1=	MONS_Number		; Incrémente MONS_Number	A=DAT1(P)	A=A+1(P)	DAT1=A(P).next	D0=D0+2			; Elément suivant du tableau	LC(2)	8	A=R1	A=A+C(B)	R1=A	B=B-1(B)	?B=0(B)	GOYES	.col	GOTO	.column.col	A=0	R1=A	A=R2	A=A+C(B)	R2=A	D=D-1(X)	?D=0(X)	GOYES	.lin	GOTO	.line.lin	A=R0	D1=PAC_ToEat	DAT1=A* INITIALISATIONS DES POSITIONS ECRAN*  Pour que l'affichage soit bon, ces positions doivent provoquer un scrolling*  la première fois que le tableau est affiché	D0=	PAC_PosX	D1=	SCRN_LastX	LC	128	A=DAT0(X)	A=A+C(X)	DAT1(X)=A	D0=D0+3				; PAC_PosY	D1=D1+3				; SCRN_LastY	A=DAT0(X)	A=A+C(X)	DAT1(X)=A	RTNPAC_Exit:**************************************************************************			Fin du jeu					***************************************************************************	GOSBVL	ROM_LoadRegs*	C=DAT1				; Récupère la sauvegarde dans la pile*	D0=C**	D0=D0+10			; Copie D0=sauvegarde ...*	D1=	VARS_Start		; ... dans D1=Variables ...*	LC	VARS_End - VARS_Start	; ... longueur des variables.**	GOSBVL	ROM_MoveDn* Restauration de l'écran	D0=	RRAM_ScreenBase	A=DAT0	D0=	HARD_ScreenBase	DAT0=A	D0=	RRAM_ScreenMenuBase	A=DAT0	D0=	HARD_ScreenMenuBase	DAT0=A	D0=	HARD_ScreenShift	LC(1)	8	DAT0=C(1)	D0=	HARD_ScreenWidth	C(X)=0	DAT0=C(X)* Restaure le contenu des registres sauvegardés	GOSBVL	ROM_LoadRegs* Restaure les interruptions et retourne	ST(15)=1	RTN;	GOVLNG	$10E5			; Restaure les interruptionsWAIT5:	RSTK=C.1	LC(4)	4	OUT=CS	GOSBVL	ROM_InputC	?CBIT(2)=0	GOYES	.1.2	LC(4)	4	OUT=CS	GOSBVL	ROM_InputC	?CBIT(2)=1	GOYES	.2	C=0	OUT=CS	C=RSTK	RTN      END    END@ ***********************************************************************@ *		Affichage d'un texte défilant pour ABOUT		*@ ***********************************************************************  AboutCode    INCLUDE "ABOUT.48S"END