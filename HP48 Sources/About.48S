@ ***********************************************************************@ *		Affichage d'un texte (string niv 1) en défilement	*@ ***********************************************************************PROG  Check1 <3>		@ Verifie si bien une chaine sur pile  ASM		INCLUDE	"RRAM.48S"		INCLUDE	"ROM.48S"		INCLUDE	"HARD.48S"* Parameters of the display routineWaitDelay	equ	600	; Delay between two displaysFirstLine	equ	20	; First line where to display textCharHeight	equ	1	; Multiply factor for text* Set variables at beginning of free system variables		RSSET	RRAM_Free70TEXT_Pointer	RS	5	; Current char to be readTEXT_Begin	RS	5	; Beginning of the char stringTEXT_End	RS	5	; End of the char stringCHAR_Data	RS	16	; Current char to be displayed* Initialization		GOSBVL	ROM_SaveRegs	; Save all RPL registers		A=DAT1			; Read stack to find string		AD1EX		D1=D1+5		C=DAT1			; C = String length		D0=	TEXT_Pointer		D1=D1+5		AD1EX		DAT0=A			; TEXT_Pointer		D0=D0+5		DAT0=A			; TEXT_Begin		D0=D0+5		A=A-5		A=A+C		DAT0=A			; TEXT_EndCharacterLoop	D0=	TEXT_Pointer		A=DAT0		D0=A		A=0		A=DAT0(B)		LC(2)	32		?A>C(B)		GOYES	.nospace		A=C(B).nospace	ASL			; A*16: pointer to char		LC	ROM_CharSet2-496		A=A+C		D0=A		GOSUB	.findadr.findadr	C=RSTK			; Adresse de .findadr		A=C		LC	$80000		?A>C			; Not in HRAM: easy		GOYES	.easy* Difficult case: Must deconfigure $C0000 module to "see" HROM		LC	$C0000		UNCNFG		LC	$80000		AD0EX		A=A+C			; See HROM second block		AD0EX		A=DAT0(W)		LC	$C0000		CONFIG			; Reconfig second module		CONFIG			; in $C0000		GOTO	.read* Easy case: PC is after $80000 -> it is possible to configure RRAM down.easy		LC	$70000		; Put HRAM in $60000		UNCNFG		LC	$F0000		CONFIG		LC	$60000		CONFIG		A=DAT0(W)		UNCNFG			; Put HRAM in $70000		LC	$F0000		CONFIG		LC	$70000		CONFIG		GOTO	.read* Data read in A.read		D1=	CHAR_Data		DAT1(W)=A		; Write char description		LC(2)	5		; Shifts to output char		D=C(B)ShiftLoop	D0=	RRAM_GROBStack		A=DAT0		LC	CharHeight*8+FirstLine*34+20	; NO PRECEDENCE…		A=A+C			; Bottom of display line		D0=A			; D0= ptr to screen* Scroll screen 1 pixel to the left		LC(3)	34*4*Charheight	; Shifts for screen scroll		ABIT(8)=0.shiftscreen	A=DAT0(B)		; Scroll screen 1 pixel left		ABIT(9)=0		?ABIT(0)=0		GOYES	.nobit1		ABIT(9)=1.nobit1		ASRB		DAT0(B)=A		D0=D0-2		C=C-1(X)		GONC	.shiftscreen* Display character		D0=	RRAM_GROBStack		A=DAT0		LC	34*FirstLine+34+20-2	; Stack display data		A=A+C		D0=A			; D0= ptr to screen		D1=	CHAR_Data	; Char description		LC(2)	7		P=15		LC(1)	CharHeight-1		P=0		B=C(B).char		C=DAT0(B)		CBIT(7)=0		A=DAT1(B)		?ABIT(0)=0		GOYES	.carry_char		CBIT(7)=1.carry_char	A=A/2(B)		DAT1(B)=A		D1=D1+2		B=C(S).lineHeight	DAT0(B)=C		D0=D0+16		D0=D0+16		D0=D0+2		B=B-1(S)		GONC	.lineHeight		B=B-1(B)		GONC	.char		LC	WaitDelay.wait		C=C-1		GONC	.wait		LC(4)	$1FF		OUT=CS		GOSBVL	ROM_InputA		?A=0(X)		GOYES	noTerminate		GOTO	TerminatenoTerminate	D=D-1(B)		GOC	ShiftLoopEnd		GOTO	ShiftLoopShiftLoopEnd	D0=	TEXT_Pointer		A=DAT0			; TEXT_Pointer		A=A+2		D0=D0+10		C=DAT0			; TEXT_End		D0=D0-5		?A<C		GOYES	.ok		GOTO	Terminate	; Quit program.ok		D0=D0-5		DAT0=A			; TEXT_Pointer		GOTO	CharacterLoop* Quit program when key pressedTerminate	GOSBVL	ROM_LoadRegs		A=DAT0		D0=D0+5		PC=(A)  ENDEND