LIBRARY 1205 "REC 2.0Receive Object from HPDSFormat: (Size)*(Object)#CRCEx: A0000*D9D20B2130#5485"COMMANDS RECCONFIG  PROG    1205 ATTACH  ENDMESSAGES[  "Expecting *"		@ Size not followed by *  "Wrong checksum"	@ Computed and transmitted checksum do not match  "Expecting #"		@ Object not terminated by #  "Hex digits only"	@ Received not hexa digit  "Stack is full"	@ Not enough space on stack   "Hardware overrun"	@ RS232 Hardware overrun]CONTENTREC  PROG    Check0			@ Set command number    ASM	INCLUDE	"ROM.48G"	INCLUDE	"RRAM.48G"	INCLUDE	"HARD.48G"	GOSBVL	ROM_SaveRegs	GOSBVL	ROM_GarbColl		; Réorganise la mémoire	D0=	HARD_UARTInterrupt	LC(1)	8	DAT0=C(P)	A=0	R1=A				; Taille initiale allouée = 0.* Compute size in Free70, then in C	D1=	RRAM_Free70	LC(1)	4	B=C(P)SizeLoop:	GOSUB	ReadChar	GOC	NotHexa	DAT1(P)=C	D1=D1+1	B=B-1(P)	GONC	SizeLoop	D1=D1-5	GOSUB	ReadChar	LC(2)	"*"	?A=C(B)	GOYES	ReserveObject	LC(1)	1	GOTO	DoErrorReserveObject:	C=DAT1	R1=C				; R1= size to read	GOSBVL	ROM_ResRoom	CD0EX	R0=C				; R0= Adress of object	GOSBVL	ROM_LoadRegs	?D<>0	GOYES	FreeSpc	LC(1)	5	GOTO	DoErrorNotHexa	LC(1)	4	GOTO	DoErrorFreeSpc	D=D-1	D1=D1-5	C=R0	DAT1=C	GOSBVL	ROM_SaveRegs	C=R0	D1=C	A=R1	B=AObjectLoop:	?B=0	GOYES	.end	GOSUB	ReadChar	GOC	NotHexa	DAT1=C(P)	D1=D1+1	B=B-1	GOTO	ObjectLoop.end	GOSUB	ReadChar	LC(2)	"#"	?A=C(B)	GOYES	.ok	LC(1)	3	GOTO	DoError* Compute Checksum in RRAM_Free70.ok	D1=	RRAM_Free70	LC(1)	3	B=C(P)ChkSLoop:	GOSUB	ReadChar	GOC	NotHexa	DAT1(P)=C	D1=D1+1	B=B-1(P)	GONC	ChkSLoop* Compute object checksum	D1=	HARD_Checksum	C=0	DAT1=C	A=R1			; A= size	C=R0	D0=C			; D1= object pointer	INTOFFChecksum:	?A=0	GOYES	.end	C=DAT0(P)	D0=D0+1	A=A-1	GOTO	Checksum.end	A=DAT1	INTON	D1=	RRAM_Free70	C=DAT1	P=3	?A=C(WP)	GOYES	.ok	P=0	LC(1)	2	GOTO	DoError.ok	P=0Quit	D0=	HARD_UARTInterrupt	LC(1)	0	DAT0=C(P)	GOVLNG	ROM_LoadRegsEnd* DoError: Output errorDoError	A=R1				; Si l'objet est complètement invalide	B=A				; ROM_GarbColl peut se planter	A=R0	D0=A	A=0	B=B-1	GOC	.end.clear	DAT0=A(P)	D0=D0+1	B=B-1	GONC	.clear	.end	R0=C	D0=	HARD_UARTInterrupt	LC(1)	0	DAT0=C(P)	GOSBVL	ROM_LoadRegs	LC	$4B500	A=C	C=R0	A=C(P)	GOVLNG	ROM_ErrorOverRun	ST(15)=1	C=RSTK	LC(1)	6	GOTO	DoError* ReadChar: Puts read char in A(B), digit value in C* Corrupts A, D0, CReadChar:	D0=	HARD_ScreenIndicators	A=DAT0(B)	ABIT(5)=1	DAT0(B)=A	ST(15)=0			; Disable interrupts	LC(5)	40000.wait	D0=D0+	HARD_UARTControl-HARD_ScreenIndicators	A=DAT0(P)			; Wait until char read	D0=D0-	HARD_UARTControl-HARD_ScreenIndicators	DAT0(P)=A	?ABIT(2)=1	GOYES	OverRun	C=C-1	GOC	OverRun	?ABIT(0)=0	GOYES	.wait	A=DAT0(B)	ABIT(5)=0	DAT0(B)=A	D0=	HARD_UARTReceive	A=DAT0(B)	D0=	HARD_UARTControl	C=DAT0(P)	CBIT(0)=0	DAT0(P)=C	ST(15)=1			; Restore interrupts	LC(2)	"F"	?A>C(B)	GOYES	.nothex	LC(2)	"0"	C=A-C(B)	GOC	.nothex	C=C-10(B)	GOC	.deci	C=C-7(B)	GOC	.nothex.deci	C=C+10(B)	RTNCC.nothex	RTNSC    END  ENDEND