@ ***********************************************************************@ *	Affichage d'un texte (string niv 1) en défilement vertical	*@ ***********************************************************************PROG  Check1 <3>		@ Verifie si bien une chaine sur pile  PROG	ASM* Parameters of the display routineWaitDelay	equ	3600	; Delay between two displays* Registers usage* R0: Current line pointer* R1: End of text* R2: Start of text screen* R3: Last line of text screen* B: Offset dans la ligne du caractère courant (0, 2, …)* D: Offset dans le caractère de la ligne courante (0, 2, …)* ST(0): 1 if odd column* ST(1): 1 if bold, toggle with £B ou £b* ST(2): 1 if inverse video, toggle with £I ou £i* InitializationVertABOUT	GOSBVL	ROM_SaveRegs	; Save all RPL registers		A=DAT1			; Read stack to find string		AD1EX		D1=D1+5		C=DAT1			; C = String length		D1=D1+5		AD1EX		R0=A			; Start of text		A=A+C		A=A-5		R1=A			; End of text		D0=RRAM_GROBStack		A=DAT0		LC	20		A=A+C		R2=A			; Start of text screen		LC	34*55		A=A+C		R3=A			; Last line of text screen		ST(15)=0		; Coupe les interruptions clavier* This is the loop for every line of text.LineLoop	D=0			; 2 * Number of current line* This is the loop for every line of the screen.ScrollLoop	ST(0)=0			; Start of line is even* Scroll screen one line up		A=R2			; Base of screen		D1=A			; Destination		LC	34		A=A+C		D0=A		LC	34*55		; Number of q to scroll		GOSBVL	ROM_MoveDn* Clear last line		A=R3		D0=A		C=0(W)		DAT0=C(W)		D0=D0+16		DAT0=C(W)		D0=D0+16		DAT0=C(B)		A=R3			; Pointeur to bottom line		D1=A			; Pointer to current text column		ST(1)=0			; Set default text style settings		ST(2)=0		A=R0		D0=A* This is the loop for every char in the line.CharLoop	AD0EX		D0=A		C=R1			; Si fin du texte		?A>=C		GOYES	.newline2		A=0		A=DAT0(B)		D0=D0+2		LC(2)	"£"		; Changements de style		?A=C(B)		GOYES	.style		LC(2)	31		?A>=C(B)		GOYES	.noctl* Teste si retour chariot ou autre		LC(2)	10		; Retour chariot		?A=C(B)		GOYES	.newline2		LC(2)	"•"		; Affiche un caractère quelconque		A=C(B)		GOTO	.noctl.newline2	GOTO	.newline* Gestion des styles.style		A=DAT0(B)		; Read style char		D0=D0+2		LC(2)	"W"		?A<>C(B)		GOYES	.noswait		?D<>0(P)		; Attente seulement en début de scroll		GOYES	.CharLoop		LC	$10000.swait		C=C-1		GONC	.swait		GOTO	.CharLoop.noswait	LC(2)	"B"		; Bold		?A<>C(B)		GOYES	.nobold1		ST(1)=1		GOTO	.CharLoop.nobold1	LC(2)	"b"		?A<>C(B)		GOYES	.nobold0		ST(1)=0		GOTO	.CharLoop.nobold0	LC(2)	"I"		?A<>C(B)		GOYES	.noinv1		ST(2)=1		GOTO	.CharLoop.noinv1		LC(2)	"i"		?A<>C(B)		GOYES	.noctl		ST(2)=0		GOTO	.CharLoop	.noctl		ASL			; A*16: pointer to char		LC	ROM_CharSet2-496		A=A+C		C=D			; Offset to line		A=A+C		AD0EX			; Sauvegarde D0		B=A		A=PC			; Read current address		LC	$80000		?A>C			; Not in HRAM: easy		GOYES	.easy* Difficult case: Must deconfigure $C0000 module to "see" HROM		LC	$C0000		UNCNFG		LC	$80000		AD0EX		A=A+C			; See HROM second block		AD0EX		A=DAT0(B)		LC	$C0000		CONFIG			; Reconfig second module		CONFIG			; in $C0000		GOTO	.read* Easy case: PC is after $80000 -> it is possible to configure RRAM down.easy		LC	$70000		; Put HRAM in $60000		UNCNFG		LC	$F0000		CONFIG		LC	$60000		CONFIG		A=DAT0(B)		UNCNFG			; Put HRAM in $70000		LC	$F0000		CONFIG		LC	$70000		CONFIG* Here, the good byte is in A.read		C=B		CD0EX			; Restaure D0		?ST(1)=0		; Si pas gras		GOYES	.nobold		C=A(B)		A=A+A(B)		A=A|C(B).nobold		?ST(2)=0		; Si pas inverse		GOYES	.noinv		A=-A-1(B)		LC(2)	$3F		; Preserve high bits in screen		A=A&C(B).noinv		?ST(0)=1		; Si colonne impaire		GOYES	.oddcol		ST(0)=1		DAT1(B)=A		D1=D1+1			; Progression d'un seul quartet		GOTO	.nextchar.oddcol		ST(0)=0		A=A+A(B)		A=A+A(B)		C=DAT1(P)		A=A|C(P)		; On peut faire un simple OR, car 0 à l'écran		DAT1(B)=A		D1=D1+2			; Avance de 2 quartets.nextchar	AD1EX			; Si à la fin de la ligne,		D1=A		C=R3		A=A-C		LC(2)	32		; Si on écrit à la fin		?A>C(B)		GOYES	.endline		GOTO	.CharLoop.endline	A=DAT0(B)		; Teste si un CR à la fin de la ligne		LC(2)	10		?A<>C(B)		GOYES	.newline		D0=D0+2			; Si oui, le saute.newline	LC(3)	$1FF		OUT=C		GOSBVL	ROM_InputA		C=0(X)		OUT=C		?ABIT(0)=1		; Touche de la rangée de droite		GOYES	.exit		LC(2)	$1F		A=A&C(B)		?A<>0(B)		GOYES	.nowait		LC	WaitDelay.wait		C=C-1		GONC	.wait.nowait		D=D+2(P)		; Offset de ligne		?D=0(P)		GOYES	.nextline		GOTO	.ScrollLoop.nextline	AD0EX			; Pointeur de caractères actuel		R0=A			; Stocke dans le nouveau début de ligne		C=R1		?A>=C		GOYES	.exit		GOTO	.LineLoop.exit		ST(0)=0			; Restaure les drapeaux utilisés		ST(1)=0		ST(2)=0.waitkey	LC(3)	$1FF		OUT=C		GOSBVL	ROM_InputA		C=0(X)		OUT=C		LC(2)	$1F		A=A&C(B)		?A=0(B)		GOYES	.waitkey		GOSBVL	ROM_RestoreIT	; Reinitialise les interruptions		GOVLNG	ROM_LoadRegsEnd	; Retour au RPL	END ; ASM	DROP  ENDEND