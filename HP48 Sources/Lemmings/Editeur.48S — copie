@ ***********************************************************************@ *									*@ *			Editeur pour LEMMINGS				*@ *									*@ *		Written in january 1993 by C. de DINECHIN		*@ *				using HPDS 2.2				*@ *									*@ ***********************************************************************LIBRARY 1214"LEMEDITEditeur pour LEMMINGS (Lib 1213),(C) C.de DINECHIN, V1.0b du 6/03/1993"  COMMANDS    EditLEM AboutLEMEdit  COMMANDS    TimeLEM    NStartLEM DelayLEM    NExitLEM    ParaLEM StopLEM DigLEM ClimbLEM ConsLEM ExploLEM    TitleLEM  CONFIG    PROG	1214 ATTACH	DEFLIB 1213		LEM LevelLEM AboutLEM		DecompactLEM LEMCode LEMSprites LEMMenus LEMPatterns LEMScreen		Display VScroll	END    ENDCONTENT@ ***********************************************************************@ *									*@ *		Editeur de tableaux pour LEMMINGS			*@ *									*@ ***********************************************************************AboutLEMEdit	PROG@234567890123456789012"      £I LEMEDIT Cette librairie est unéditeur de tableauxpour la librairie 1213£BLEMMINGS£b.£W      £I L'éditeur Pour créer un tableaude 16n pixels de largeet 16m pixels de haut,placez sur la pile unGROB 8n m et appelez£BLEMEdit£b.£WLes flèches déplacentle curseur.£W+ et - changent legraphisme affiché.£WSPC répète le derniergraphisme utilisé.£W. mémorise le graphisme sous lecurseur pour copieultérieure avec SPC.£W  £I Autres commandes Les autres commandesde la librairiepermettent de modifierle Library Data créépar EditLEM, placé auniveau 2.£WLa nouvelle valeur duparamètre est placéedans un réel au niveau1 de la pile.£W£BTime£b: Temps total (s)£BNStart£b: Lems créés£BDelay£b: Temps entre 2lemmings crés (1/10s)£BNExit£b: Lems à sauver£BTitle£b: Nom du niveau£W£BPara£b: Parachutistes£BStop£b: Stoppeurs£BDig£b: Creuseurs£BClimb£b: Escaladeurs£BCons£b: Constructeurs£BExplo£b: Bombes£W £I La variable LEMDAT Cette variable stockevos tableaux. Cestableaux ont prioritésur ceux de Lemmings.£WChaque élément de laliste est une listecontenant le GROB etle Library data£W" VScroll	ENDEditLEM	PROG		Check1 <Ch>	@ Vérifie qu'il y a un GROB dans la pile		PROG			LEMPatterns			SWAP			NEWOB		@ Duplique le tableau (si dans lib.)			{ #0 #0 } PVIEW	@ Affiche le mode graphique			ASM	INCLUDE	"HARD.48S"	INCLUDE	"ROM.48S"	INCLUDE	"RRAM.48S"	RSSET	RRAM_RS232BufferSizeX	RS	3			; Taille en nombre de motifsSizeY	RS	3			; Taille en nombre de motifsOffsetX	RS	3			; Offset bord haut gauche écranOffsetY	RS	3CrsrX	RS	3			; Position du curseurCrsrY	RS	3Motifs	RS	5			; Pointeur vers les motifsTableau	RS	5			; Pointeur vers le tableau	GOSBVL	ROM_SaveRegs* Initialisation du tableau	A=DAT1				; Niveau 1: Tableau	D0=A	D0=D0+10			; Taille Y	C=DAT0	D0=SizeY	DAT0=C(X)	D0=A	D0=D0+15			; Taille X	C=DAT0	C=C/2	C=C/2	C=C/2				; En nombre de motifs	D0=SizeX	DAT0=C(X)	LC	20			; Taille prologue + dims	A=A+C	D0=Tableau	DAT0=A				; stocke ptr tableau* Initialisation des motifs	D1=D1+5	A=DAT1	LC	20	A=A+C	D0=Motifs	DAT0=A				; Stocke ptr motifs* Initialisation des positions curseur, etc	C=0	D0=OffsetX	DAT0=C(X)	D0=D0+3				; OffsetY	DAT0=C(X)	D0=D0+3				; CrsrX	DAT0=C(X)	D0=D0+3				; CrsrY	DAT0=C(X)* Passe en plein écran	D0=	HARD_ScreenHeight	LC(2)	63	DAT0(B)=C*BOUCLE PRINCIPALEEDITORLOOP	GOSUBL	DisplayAll* Définition des touchesKeyUp	equ	$0BKeyLf	equ	$10KeyDn	equ	$11KeyRt	equ	$12KeyEnt	equ	$19KeyPl	equ	$31KeyMn	equ	$2CKeyPt	equ	$2FKeySp	equ	$30	GOSUB	WaitKey* Teste si on quitte l'éditeur	LC(2)	KeyEnt	?A<>C(B)	GOYES	.noexit	GOTO	.exit* Touches de motification.noexit	C=R0	D0=C	C=DAT0(B)	B=C(B)	LC(2)	KeyPl	?A<>C(B)	GOYES	.nopl	B=B+1(B)	C=B(B)	R1=C.nopl	LC(2)	KeyMn	?A<>C(B)	GOYES	.nomn	B=B-1(B)	C=B(B)	R1=C.nomn	LC(2)	KeySp	?A<>C(B)	GOYES	.nosp	C=R1	B=C(B).nosp	LC(2)	KeyPt	?A<>C(B)	GOYES	.nopt	C=B(B)	R1=C.nopt	C=B(B)	DAT0(B)=C* Touches de déplacement	D0=CrsrX	C=DAT0(X)	B=C(X)	D0=D0+3	C=DAT0(X)	D=C(X)	LC(2)	KeyUp	?A<>C(B)	GOYES	.noup	D=D-1(X)	GONC	.noup	D=0(X).noup	LC(2)	KeyLf	?A<>C(B)	GOYES	.nolf	B=B-1(X)	GONC	.nolf	B=0(X).nolf	LC(2)	KeyDn	?A<>C(B)	GOYES	.nodn	D=D+1(X)	D0=	SizeY	C=DAT0(X)	?D<C(X)	GOYES	.nodn	D=C(X)	D=D-1(X).nodn	LC(2)	KeyRt	?A<>C(B)	GOYES	.nort	B=B+1(X)	D0=	SizeX	C=DAT0(X)	?B<C(X)	GOYES	.nort	B=C(X)	B=B-1(X)* Ecriture des nouvelles coordonnées.nort	D0=	CrsrX	C=B(X)	DAT0(X)=C	D0=D0+3	; CrsrY	C=D(X)	DAT0(X)=C* Calcule l'offset du point haut gauche	D0=	OffsetX	C=DAT0(X)	?B>=C(X)	GOYES	.ox1ok	C=B(X)	DAT0=C(X).ox1ok	B=B-7(X)	GOC	.ox2ok	?C>=B(X)	GOYES	.ox2ok	C=B(X)	DAT0(X)=C.ox2ok	D0=D0+3		; OffsetY	C=DAT0	?D>=C(X)	GOYES	.oy1ok	C=D(X)	DAT0(X)=C.oy1ok	D=D-3(X)	GOC	.oy2ok	?C>=D(X)	GOYES	.oy2ok	C=D(X)	DAT0=C(X).oy2ok* Boucle principale de l'éditeur	GOTO	EDITORLOOP* Quitte l'éditeur.exit	ST(0)=0	GOVLNG	ROM_LoadRegsEnd* Attend une touche stockée dans AWaitKey:.wait	D0=RRAM_KeyBufferStart	A=0	A=DAT0(P)	D0=D0+1	C=0	C=DAT0(P)	D0=D0+1	?C=A(P)	GOYES	.wait	ST(15)=0	D0=D0-2	A=A+1(P)	DAT0(P)=A	A=A-1(P)	D0=D0+2	ST(15)=1	A=A+A	CD0EX	C=C+A	CD0EX	A=DAT0(B)	RTN* Affiche tout le tableauDisplayAll:	D0=	RRAM_GROBCurrent	A=DAT0	LC	20		; Taille prologue + Dims	A=A+C	LC	34*16*3		; Offset ligne	A=A+C	LC	7*4		; Offset colonne	A=A+C			; Pointe sur l'écran de pile	D1=A			; Destination	P=2	LC(1)	3		; Nombre de lignes	P=0.yloop	LC(1)	7		; Nombre de colonnes.xloop	RSTK=C	ST(0)=1			; Indique case édit	A=0	A=C(XS)			; Lecture offset Y	ASR	ASR	D0=OffsetY	C=0	C=DAT0(X)	A=A+C	D0=CrsrY	C=DAT0(X)	?A=C(X)	GOYES	.oky	ST(0)=0.oky	D0=SizeX	C=0	C=DAT0(X)	C=C+C	GOSBVL	ROM_B_is_AxC	C=RSTK	RSTK=C	A=0	A=C(P)			; Lecture offset X	D0=OffsetX	C=0	C=DAT0(X)	C=C+A	D0=CrsrX	A=DAT0(X)	?A=C(X)	GOYES	.okx	ST(0)=0.okx	C=C+C	C=C+B	D0=Tableau	A=DAT0	A=A+C	D0=A			; D0 pointe sur la case du tableau	?ST(0)=0	GOYES	.nocpy	R0=A.nocpy	A=0	A=DAT0(B)	C=A			; Lit le numéro de colonne dans les motifs	CSR	CSL			; x 16	CSL			; x 256	C=C+C			; x 512	C=C+C			; x 1024	Taille d'une ligne	P=1	A(P)=0	P=0	A=A+A			; x 2		Offset colonne	A=A+A			; x 4	C=C+A			; Début du motif	D0=Motifs	A=DAT0	C=C+A	D0=C			; D0 pointe sur le début du motif	C(S)=0	C=C-1(S)	P=3			; 16 bits.lloop	A=DAT0(WP)	?ST(0)=0	GOYES	.noinv	A=-A-1(WP).noinv	DAT1(WP)=A	D1=D1+16	D1=D1+16	D1=D1+2	D0=D0+16	D0=D0+16	D0=D0+16	D0=D0+16	C=C-1(S)	GONC	.lloop	P=0	LC	34*16+4	AD1EX	A=A-C	AD1EX	C=RSTK	C=C-1(P)	GOC	.xxloop	GOTO	.xloop.xxloop	RSTK=C	LC	34*15+2	AD1EX	A=A-C	AD1EX	C=RSTK	C=C-1(XS)	RTNC	GOTO	.yloop	END	; ASM@ Crée un "Library data" par défaut pour les caractéristiques du tableau			SWAP DROP			LIBDATA	8008000204008080081818181818181000F00202020202020202			NEWOB			ASMFINDINOUT		GOSBVL	ROM_SaveRegs			D1=D1+5			; Le GROB			A=DAT1			D0=A			D0=D0+10		; Taille Y			A=DAT0			R2=A			D0=D0+5			C=DAT0			; Taille X			C=C/2			C=C/2			C=C/2			R1=C			D0=D0+5			D1=D1-5			; Le LIBDATA			A=DAT1			D1=A			D1=D1+10		; Pointe sur PosX			D=0			; Initialise Y.yloop			B=0			; Initialise X.xloop			C=DAT0(B)			C=C-1(B)			?C<>0(B)		; Pas une entrée			GOYES	.noin			C=B(X)			CSL			C=C+4			DAT1=C(X)			D1=D1+3			C=D(X)			CSL			C=C+4			DAT1=C(X)			D1=D1-3			GOTO	.nout.noin			C=C-1(B)			?C<>0			GOYES	.nout			C=B(X)			CSL			C=C+4			D1=D1+11			DAT1=C(X)			D1=D1+3			C=D(X)			CSL			C=C+4			DAT1=C(X)			D1=D1-14			.nout			D0=D0+2			B=B+1			A=R1			?B<A			GOYES	.xloop			D=D+1			C=R2			?D<C			GOYES	.yloop			GOVLNG	ROM_LoadRegsEnd			END			{ EditLEM TitleLEM TimeLEM NStartLEM DelayLEM NExitLEM			  ParaLEM StopLEM DigLEM ClimbLEM ConsLEM ExploLEM }			TMENU		END	END@ ***********************************************************************@ *									*@ *		Editeur dees caractéristiques des tableaux		*@ *									*@ ***********************************************************************@ Tous ces éditeurs prennent un library data et un réel sauf TitleLEMTimeLEM	PROG		Check2 <AF1h>		PROG			R->B			ASM			GOSBVL	ROM_SaveRegs			A=DAT1			D0=A			D0=D0+10			C=DAT0		; Lit la valeur			B=C			D1=D1+5			A=DAT1			LC	10+31	; Offset vers la valeur			A=A+C			D0=A			C=B			DAT0=C			GOVLNG	ROM_LoadRegsEnd			END			DROP		END	ENDNStartLEM	PROG		Check2 <AF1h>		PROG			R->B			ASM			GOSBVL	ROM_SaveRegs			A=DAT1			D0=A			D0=D0+10			C=DAT0		; Lit la valeur			B=C			D1=D1+5			A=DAT1			LC	10+6	; Offset vers la valeur			A=A+C			D0=A			C=B			DAT0=C(B)			GOVLNG	ROM_LoadRegsEnd			END			DROP		END	ENDDelayLEM	PROG		Check2 <AF1h>		PROG			R->B			ASM			GOSBVL	ROM_SaveRegs			A=DAT1			D0=A			D0=D0+10			C=DAT0		; Lit la valeur			B=C			D1=D1+5			A=DAT1			LC	10+8	; Offset vers la valeur			A=A+C			D0=A			C=B			DAT0=C(X)			GOVLNG	ROM_LoadRegsEnd			END			DROP		END	ENDNExitLEM	PROG		Check2 <AF1h>		PROG			R->B			ASM			GOSBVL	ROM_SaveRegs			A=DAT1			D0=A			D0=D0+10			C=DAT0		; Lit la valeur			B=C			D1=D1+5			A=DAT1			LC	10+17	; Offset vers la valeur			A=A+C			D0=A			C=B			DAT0=C(B)			GOVLNG	ROM_LoadRegsEnd			END			DROP		END	ENDParaLEM	PROG		Check2 <AF1h>		PROG			R->B			ASM			GOSBVL	ROM_SaveRegs			A=DAT1			D0=A			D0=D0+10			C=DAT0		; Lit la valeur			B=C			D1=D1+5			A=DAT1			LC	10+19	; Offset vers la valeur			A=A+C			D0=A			C=B			DAT0=C(B)			GOVLNG	ROM_LoadRegsEnd			END			DROP		END	ENDStopLEM	PROG		Check2 <AF1h>		PROG			R->B			ASM			GOSBVL	ROM_SaveRegs			A=DAT1			D0=A			D0=D0+10			C=DAT0		; Lit la valeur			B=C			D1=D1+5			A=DAT1			LC	10+21	; Offset vers la valeur			A=A+C			D0=A			C=B			DAT0=C(B)			GOVLNG	ROM_LoadRegsEnd			END			DROP		END	ENDDigLEM	PROG		Check2 <AF1h>		PROG			R->B			ASM			GOSBVL	ROM_SaveRegs			A=DAT1			D0=A			D0=D0+10			C=DAT0		; Lit la valeur			B=C			D1=D1+5			A=DAT1			LC	10+23	; Offset vers la valeur			A=A+C			D0=A			C=B			DAT0=C(B)			GOVLNG	ROM_LoadRegsEnd			END			DROP		END	ENDClimbLEM	PROG		Check2 <AF1h>		PROG			R->B			ASM			GOSBVL	ROM_SaveRegs			A=DAT1			D0=A			D0=D0+10			C=DAT0		; Lit la valeur			B=C			D1=D1+5			A=DAT1			LC	10+25	; Offset vers la valeur			A=A+C			D0=A			C=B			DAT0=C(B)			GOVLNG	ROM_LoadRegsEnd			END			DROP		END	ENDConsLEM 	PROG		Check2 <AF1h>		PROG			R->B			ASM			GOSBVL	ROM_SaveRegs			A=DAT1			D0=A			D0=D0+10			C=DAT0		; Lit la valeur			B=C			D1=D1+5			A=DAT1			LC	10+27	; Offset vers la valeur			A=A+C			D0=A			C=B			DAT0=C(B)			GOVLNG	ROM_LoadRegsEnd			END			DROP		END	ENDExploLEM	PROG		Check2 <AF1h>		PROG			R->B			ASM			GOSBVL	ROM_SaveRegs			A=DAT1			D0=A			D0=D0+10			C=DAT0		; Lit la valeur			B=C			D1=D1+5			A=DAT1			LC	10+29	; Offset vers la valeur			A=A+C			D0=A			C=B			DAT0=C(B)			GOVLNG	ROM_LoadRegsEnd			END			DROP		END	ENDTitleLEM	PROG		Check2 <AF3h>		PROG			"        " + 1 8 SUB			ASMSETTITLE		GOSBVL	ROM_SaveRegs			A=DAT1			D0=A			D0=D0+10	; Début de la chaîne			D1=D1+5			A=DAT1			LC	10+35	; Offset vers la valeur			A=A+C			D1=A			LC(1)	7	; Nb de caractères à copier.cpy			A=DAT0(B)			DAT1=A(B)			D0=D0+2			D1=D1+2			C=C-1(P)			GONC	.cpy			GOVLNG	ROM_LoadRegsEnd			END			DROP		END	ENDEND