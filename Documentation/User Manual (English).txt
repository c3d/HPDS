**************************************************************************									**		HP-48 Developpement System for Atari ST			**				HPDS V2.1				**	Written in November 1991 by Christophe de DINECHIN		**									****************************************************************************************************************************************************									**			  NEWS 2.1					**									**************************************************************************HPDS V2.1 has several improvements vs. V2.0. They are:- V2.1 handles international character set in any object. It is now  possible to have names or strings containing special characters (Ž,ˆ,...),  they will be translated to their equivalent in the HP48 character set.- More than one object may be put in an include file.- Their is now only one symbol table for	+ Assembler labels	+ Externals	+ Global names	+ Local names	+ Structures names (IF, THEN, etc).  This symbol table is kept accross different code objects. For example, it  is now possible to call from one Code object routines in another Code  object, or to have a reference to an external address.  - All externals are read from an external file named 'external.hp'. Thus,  you can easily define your own external objects.  - There is now a short form for 'EXTERNAL' which is '\'. You can call the  'alpha' global name with '\4358A'  - Whenever a binary value is read, many forms may now be used:	+ 1234A	+ #1234A	+ 1234Ah	+ 1524d	+ etc...  This is true for  	+ System binary <152A> (default hexa.)  	+ Library numbers and command number (default decimal)	+ External addresses.- There are new directives:	+ ORG xxxx       : Set PC value to xxxx	+ XDEF nnnn xxxx : Define an external nnnn having value xxxx	+ XHERE nnnn     : Define an external nnnn referencing current PC.- Internal organization of the program is far better. There should be a  great improvement in RPL compilation speed.**************************************************************************									**			INTRODUCTION					**									**************************************************************************I APOLOGIZE-----------  This documentation and the HPDS source files are written in English.This is not my mother language. I would have preferred to write all thatstuff in French. French speaking people will find it hard to have to readEnglish. English speaking people will find that my English is not exactlyacademic, that lots of things I wrote are REALLY not English, ...  I decided to use English because, in the times Atari ST was justa dream machine you could hardly find in France, I had to read lots of"technical informations" written in German. I CAN speak or read German.But German in itself is far more complicated for technical documentationsthan English. And I think that French is not that different for nonnatives...  So, I hope that, apart from English and French speaking people, readerswill find English was a good solution...  For any information about the HPDS or the HP48, please contactChristophe de DINECHIN, 4 rue A. Romain, 69140 Rillieux-la-Pape, FRANCE.WHAT IS HPDS ?--------------  Your HP-48S or HP-48SX calculator uses the RPL language (RPL stands forReverse Polish Lisp). This language is very powerful. In fact, it is usedin the calculator ROM for many applications (Equation Writer, Array Editor,Text Editor, Graphics, etc...)  This language can handle a lot of "Objects", which are stored mainly in"Variables" and in the "Stack". Each object has its own "Type". For example,the stack can contain Real or Complex numbers, character strings, integers,names, etc.  Most of these objects can be entered using the Keyboard. When you pressENTER, the calculator compiles an internal representation of the objectsin the command line and EVALuate them. But the most exciting objects thecalculator can handle are not available this way. The purpose of HPDS isto provide a compiler for almost any object the calculator knows.  In the current version, only 2 object types cannot be compiled with HPDS:- Linked Array  I have never seen any object having this type. I do not know what theyrepresent, nor their structure. If anyone knows...- Unit objects  These objects are very difficult to handle. They need an expressionanalyzer and a description of all units. When I have a little time, I willwrite the Unit Object compiler.  The other object types can be compiled using HPDS. They are:- System Binary		(1)- Real			(2)- Long Real		(1) (2)- Complex		(2)- Long Complex		(1) (2)- Character		(1)- Array			(3)- String- Binary Integer	(4)- List- Directory		(5)- Algebraic		(6)- Tagged object- Graphic- Library		(1)- Backup		(1) (7)- Library Data		(1)- Program		(8)- Code			(1) (9)- Global Name		(10)- Local Name		(10) (11)- XLIB Names		(1) (11)- Command / Functions- External		(1)- Object		(12)NOTES:-----(1). These objects cannot be compiled using only the standard HP objectcompiler. They are known because of the type description in ROM, becausesome of these objects exist in ROM. Their name is what appears in thestack when such an object is created.(2). The real numbers assume a '.' as decimal separator. The complex numbersassume rectangular mode (polar mode is not recognized). There must be noseparator (space, line-feed, ...) in a complex number. Long Real and LongComplex numbers use the same syntax, prefixed with LONGREAL or LONGCOMPLEX.(3). Non standard arrays can be compiled as well: number of dimensions > 3,such as [[[ 1 2 3]]], type of objects not real nor complex, such as[ #1 #2 #3 ], etc. String arrays are particularily useful, because theydescribe the error messages in a library. For example, [ "Error!" "Ok..."](4). The binary integers are not compiled as the ROM does. The shortestpossible binary integer is compiled (ROM compiles always 16 hex digitsintegers). For example, #0 is represented as E4A20600000. For #0, Itried the form E4A2050000, which does not work. You may compile very longbinary integers (more than 16 hex digits).(5). The directory objects compiled are actually subdirectory. The HOMEdirectory structure is slightly different, and can be found only in BACKUPobjects. The directories have no library attached.(6). The algebraic syntax is not the standard HP syntax. It uses an RPLform, to allow you to produce non standard algebraics. The expressioninterpretor will be available in a future version of HPDS. Currently, ifyou write 'A+B', the compiler understands that "A+B" is a global or alocal name. The syntax for an algebraic object is the same as the syntaxfor programs, except that "PROG" is replaced with "ALGEBRAIC".(7). The standard backup object (as produced with ARCHIVE) consist inone object and its CRC. Here, the backup object may contain as many objectsas you want, and the CRC is not automatically compiled.(8). Using the standard HP object compiler, you introduce programs with <<and you end them with >>. In fact, these delimiters are not necessary inmost of the cases, except for program editing. The actual program andend of program delimiters (which are known from HPDS as PROG and END) areinvisible, and added by the standard object compiler before << and after >>.Thus, << A B + >> is actually compiled by the standard HP compiler asPROG << A B + >> END, and has (as far as I know) exactly the same resultas PROG A B + END. The difference is that PROG PROG A B + END END executesthe inner program, but PROG PROG << A B + >> END END puts the << A B + >>program on the stack.  DO NOT FORGET that HPDS does NOT automatically produce the PROG and ENDdelimiters as does the standard HP compiler. In most of the cases, you wouldreplace << with PROG and >> with END.(9). HPDS includes a full SATURN assembler to produce machine language code.This assembler is described further.(10). HPDS allows you to produce non standard names, such as "B#(5)". Itdoes not check delimiters in a name. You can even produce almost any nameusing the GLOBALNAME "name" or LOCALNAME "name" syntax.(11). HPDS uses the context to know wether a name is a global name, a localname or an XLIB. You may define a context using DEFLIB to declare librariesthat are not known from HPDS. This is not usefull inside a LIBRARYdescription.**************************************************************************									**		THE TEXT EDITOR	- YOU WILL HATE IT			**									**************************************************************************  When you first run HPDS, you enter directly the editor. This editor isvery bad, I know it. The challenge was to make an editor which was writtenfully in C, which was not too complex and which could be ported on anymachine, including mere VT terms connected to an UNIX machine.  That's why this editor is not very fast, not very powerful, has no veryergonomic commands, does not use windowing and all the stuff... I know thiseditor is REALLY not the strongest point of HPDS.  When I begin the Mac version, I will completely rewrite the interface,including mainly the text editor, and that is why I do not want to taketoo much of my time on the current version.  On Atari ST, the keys are the following:- Arrows: move the cursor- Ctrl + Arrows: Move the cursor on paragraph up/down, to the end or to  the beginning of the line.- Delete / Backspace: Delete one char after or before the cursor.- Ctrl-K (Kill): Kill the end of the line or the line break. The text  deleted is added to the Kill/Paste buffer- Ctrl-Y (Yank): Add the text in the Kill/Paste buffer at the current  cursor.  Other commands can be found in the menus.**************************************************************************									**			THE MAIN MENU					**									**************************************************************************  The main menu is accessed by pressing the ESC key. To use a command,just press the capital letter in its name.  The available items at this level are:- Edit: Commands concerning Text editing- File: File transfer commands.- Search: Search / Replace commands- Transmit: Commands related to RS-232 transmission between host and HP48- Assemble: Commands related to text compilation into HP objects.- eXit: Exit HPDS. (press X)The commands in each menu are the following.EDIT====EDIT.BOTTOM	Go to end of textEDIT.TOP	Go to beginning of textEDIT.GOTO	Go to a given lineEDIT.SET-TAB	Set tabulationsFILE====FILE.CLEAR	Clear text bufferFILE.INCLUDE	Include file (file is put in Kill/Paste buffer)FILE.LOAD	Load file from diskFILE.SAVE	Save file to diskFILE.WRITE-BLK	Kill/Paste buffer is put onto disk When a file name is asked for, type only a few characters then theSPACE key. File name is completed until ambiguous, and all possible answersare displayed. For example, if your disk contains  TETRIS.48S TETRIS.LST PACMAN.48S PACMAN.LST PACMAN.CODjust type "P" then SPACE. The name extends to "PACMAN." and the threePACMAN.xxx files are displayed. Type "4" then SPACE, the file name extendsto "PACMAN.48S".SEARCH======SEARCH.FIND	Find text string. Upper and lower cases are differentSEARCH.NEXT	Find the next occurence of the stringSEARCH.PREVIOUS	Find the previous occurence of the stringSEARCH.REPLACE	Find and replace text strings.TRANSMIT========TRANSMIT.RECEIVE  Receive data from RS-232. Text is put in the Kill/Paste buffer.TRANSMIT.SEND  Data in the Kill/Paste buffer is sent via the RS-232TRANSMIT.DUMP-CODE  The compilation result is sent via RS-232.TRANSMIT.CONFIG  Set the RS-232 speed. Default is 9600 bauds.  All data transferred are currently pure ASCII. Kermit protocol is notyet implemented in HPDS. Would anybody send me a disk with Kermit sources ?You will find on disk a REC object designed to produce an object from RS232.The format is lllll*ccccccc.....ccccc#kkkk	- lllll : Length of object	- cc..c : Code	- kkkk  : ChecksumASSEMBLE========  Here are the most exciting commands...ASSEMBLE.ASSEMBLE  Compiles the text in the text-buffer into an HP object. Compiles ONLY ONEobject.ASSEMBLE.CODE-TO  Assembly code is either sent to a file, to the screen or nowhere.ASSEMBLE.LISTING-TO  Assembly listing is either sent to a file, to the screen or nowhere.ASSEMBLE.TARGET  Sets the SATURN target (HP48, HP28S, HP28C or HP71). Well, this isactually not very useful, because the object description is not the samefor all these machines. It checks only that machine code instructions areavailable on the given target. For example ABIT(0)=1 does not exist inthe HP71 instruction set. The result is not guaranteed, except for the HP48,which accepts all instructions.  For the ASSEMBLE.CODE-TO and ASSEMBLE.LISTING-TO commands, the name ofthe listing or code file is the same than the name of the source file, witha ".LST" or ".COD" extension.**************************************************************************									**		GENERAL RESTRICTION ABOUT THE COMPILER			**									**************************************************************************  One problem when compiling objects for the HP48 is the character set.For example, you find arrows, greek letters, a whole set of accentuatedcharacters, and so on. All these characters are not available on theAtari.  The current version of HPDS does not handle the HP48 character set AT ALL.Command names were just rewritten to conform a "full ASCII" limitation.The special characters of the Atari are used considering their ASCII code.This limitation will disappear in a future Mac version, using a specialcharacter set for the Mac and special key assignements.  The commands which have "full ASCII" names are the following:ARRY-> ->ARRY B->R C->PX C->R CLSTAT COLSTAT ->DATE D->R EQ-> ->GROBHMS-> ->HMS LCD-> ->LCD STATLINE LIST-> ->LIST UPMATCH DNMATCH NSTAT->NUM OBJ-> PX->C ->Q ->QPI R->B R->C R->D RCLSTAT SCLSTAT STOSTATSTR-> ->STR ->TAG ->TIME ->UNIT V-> ->V2 ->V3 STATX STATX^2 STATX*YSTATY STATY^2 STAT+ STAT-  The following represent commands in one special character->	Local variables assignement<<	Open program>>	Close program<=	Less or equal sign>=	Greater or equal sign<>	Different signINTEG	IntegralDERIV	DerivativePI	PiSUM	Sum ("Sigma")SQR	Square Root**************************************************************************									**			OBJECT SYNTAX					**									**************************************************************************The object syntax is given using one or more example for each.Anywhere where a separator (space, tab, line break) is expected, you can putcomments beginning with '@' and ending either with '@' or with the end ofline.SYSTEM BINARY  <12345>  <1111b>  <3Fh>  <77o>  <1444d>REAL and LONGREAL  1  0.25  -3.9991  3E241  -4.25E-38  LONGREAL 3.2E800COMPLEX and LONGCOMPLEX  (0,0)  (3.2E8;-1.5E21)  LONGCOMPLEX (-3,5)CHARACTER  CHAR "A"ARRAY  [ 1 2 3 ]  [ [ 1 2 ] [ 3 4 ] ]  [[[1 2 3] [4 5 6]]   [[7 8 9][10 11 12]]   [[13 14 15] [16 17 18]]]  [ "This is an error message" ]  [ <12345> <78889> ]STRING  "12345"  C$ 8 ABCDEFGH  Strings may contain line breaks. To enter a double quote, type a double  double quote: """Hello""" == C$ 7 "Hello"BINARY INTEGER  #12345	(default is hexadecimal)  #123451154654654654987979874654h  #1111b  #251d  #377oLIST  { THIS "IS" #Ah ->LIST }DIRECTORY  DIR    A 0    B "String"  ENDALGEBRAIC  ALGEBRAIC A B + END  ALGEBRAIC "String" Number + ENDTAGGED OBJECT  :TAG:"Tagged String"GRAPHIC  GROB 10 20 FF00FF  Data may be interrupted by line breaks, but ONLY line breaks (no spaces)LIBRARY  LIBRARY 800 "Example"    COMMANDS Cmd0		@ This command is XLIB 800 0    FUNCTIONS Func1 Func2	@ Here XLIB 800 1 and XLIB 800 2    COMMANDS Cmd3 Cmd4		@ XLIB 800 3 and XLIB 800 4    LOCAL Obj5 Obj6 Obj7	@ XLIB 800 5, ... do not appear in menu    MESSAGES    [ "Not yet implemented" "Does not work" "I don't know that" ]    CONFIG      PROG "Lib 800 installed" 1 DISP 1 WAIT END    END    CONTENT      Cmd0        PROG          #32001h DOERR	@ #800d = #320h. Error message #01        END      Func2        PROG END      Obj7        PROG END      ...      @ Other objects ...  ENDBACKUP  BACKUP "Name"    Object1    :Object2:3    "Object3"  ENDLIBRARY DATA  LIBDATA 0AFE1233625141  Any hexadecimal string. Line breaks and ONLY line breaks can be inserted.PROGRAM  PROG    IF A B = THEN      "A=B" 1 DISP    END  END  PROG << "This is a standard program" 1 DISP >> ENDCODE  ASM	LC(8) 10000LOOP	C=C-1 (W)	GONC	LOOP	A=DAT0	D0=D0+5	PC=(A)  ENDGLOBAL NAME and LOCAL NAME  GlobalName  NameIncludingSpecialCharacters+-*/#  GLOBALNAME "Name including even spaces!"  LOCALNAME "This name is local even if not in context"XLIB NAMES  DEFLIB 801    Cmd0 Func1 Cmd2 Func3	@ These objects are XLIB 801 0, XLIB 801 1...  END  XLIB 801 0  Cmd0COMMANDS / FUNCTIONS  +  -  1		@ Packed to an object in ROM  DROPEXTERNAL  EXTERNAL #12345hOBJECT  OBJECT 339205001234567890120	@ Real number...  The hexadecimal string is not checked. It can be broken only by line  breaks, without spaces nor tabs.**************************************************************************									**			THE SATURN ASSEMBLER				**									**************************************************************************  The SATURN is the microprocessor of the HP48, HP28, HP71 and othercalculators from HP. Its complete description can be found in the HDS(Hardware Design Specifications) for the HP71. Many books written bythird parties describe its instruction set. In France, one book isdedicated to the HP48 calculator: "Voyage au centre de la HP48" writtenby Paul Courbis.  The instruction set of the machine can be found in the file "codes.c".It won't be listed here. Examples of machine language sources can befound in files having a ".48S" extension.- ROM.48S contains a few entry points in HP48 ROM.- HARD.48S describes the HP48 hardware registers.- RRAM.48S describes the reserved RAM variables.- SCROLLUP.48S, SCROLLDN.48S, INVERT.48S manipulate the TEXT screen.DIFFERENCE BETWEEN HP SYNTAX and HPDS=====================================1. INSTRUCTION SIZE/FIELD  Most of the instructions accept a "size" or "field" part. In standardHP syntax, this field follows the instruction after a space.	A=DAT0	B	C=C+B	W  This is, however, not allways the case. For D0= instructions, the syntax is	D0(2)=33	D0(4)=125  This second syntax seemed to me more appropriate, easier to read. HPDSrecognizes this size field between brackets anywhere in the instruction. Soyou can as you want write	(B)A=DAT0	A(B)=DAT0	A=DAT0(B)	A=DA(B)T0	@ This is not a good idea however.  In many cases, this field has a default value if not given. For thearithmetic instructions, this default is (A). For immediate assignementas LCHEX and D0=, this default is (5).  Some instructions accept a size field which actually does not mean asize but, for example, a bit number. I kept the size field. For example,	ABIT=0	5must be written for HPDS	ABIT(5)=0which is easy to read, isn't it?2. INSTRUCTION SET  Some equivalents were added (see file codes.c), to ensure compatibilitywith my previous assemblers. For example, you can write	A=-A-1	-A-1	NOT A	A=A+B	A+B	LCHEX	33	LC	333. SPACES AND SEPARATORS  Spaces are not significant, except at the beginning of the line, wherethey tell the assembler that there is no label. So you can write	D 0 = D 0 +  54. LABELS  A label is a string beginning with a letter or a period followed byletters, digits or periods. Upper and lowercase letters are consideredequal.  The value of a label is normally the PC of the beginning of the instructionimmediatly following. This value can be changed using the EQU or RSdirectives.  Labels containing a period are local labels. In their name, the period isreplaced with the preceding global label followed by an underscore. Forexample, in the sequenceWait	LC	10000.1	C=C-1	GONC	.1the labels are WAIT (global label) and WAIT_1. Warning: no global labelmust be inserted between two reference to a given local label (that's whythey are called "local"). For example:Wait	LC	10000.1	C=C-1	GONC	.1		@ This is WAIT_1Count	LC	10000	GOTO	.1		@ This is COUNT_1.2	C=C-1.1	GONC	.2		@ Here is COUNT_15. EXPRESSIONS  Anywhere were a numerical value is expected, an expression can be given.For example,	LC	2*3+5  The main limitation is that all values are computed in 32 bits, whereasSATURN registers are up to 64 bits wide. Values greater than 2^31 are notavailable.  There is NO precedence: operations are effectued from left to right.The available operations are: negation (-), binary not (~), the fourarithmetic operations (+ - * and /), the modulo (%), the logical and (&),or (|) and exclusive or (^).  The numbers can be decimal (default), hexadecimal (when immediatelyfollowing $ or #), binary (when immediately following %) and character(a character between ").6. DIRECTIVES and PSEUDO-INSTRUCTIONS  The assembler directives and pseudo-instructions do not produce SATURNinstructions. Their name is not the same than in HP assemblers. They are:6.1 EQU or =  Following a label, this directive allow to give this label a value.SIX	EQU	3*2FIVE	=	56.2 DC (DEFINE CONSTANT)  This directive defines sized constants. Default size is 5.	DC	1,2,$3		-> 100002000030000	DC(2)	1,8,12,255	-> 1080C0FF6.3 DS (DEFINE STORAGE)  This directive defines a storage space, filled with zeroes.	DS	5		-> 000006.4 DR (DEFINE RELATIVE)  This directive defines offsets to a given location. Offset is taken fromthe start of each numberLABEL	DR	LABEL,LABEL	-> 00000BFFFF6.5 DT (DEFINE TEXT)  This directive defines ASCII text.	DT	"ABCD"		-> 142434446.6 DX (DEFINE HEXA)  This directive defines pure hexadecimal, put as such in code.	DX	12345A		-> 12345A6.7 RS (Reserve storage)  This directive reserves storage for a label. This is done by incrementinga counter (RS counter) by the number following RS. This way, you definevariables beginning at the current value of the RS counter.  See the example files for use of this directive.ADDRESS	RS	5	; Reserve 5 nibblesBYTE	RS	2	; Reserve 2 nibbles = 1 byteEXP	RS	3WHOLE	RS	166.8 RSRESET  Set RS counter to 06.9 RSSET  Set RS counter to a predefined value	RSSET	$70C00		; Location in the TEXT screen for variables6.10 ORG (ORIGIN)  Set current PC value (for the assembler, not for the processor)	ORG	$30006.11 GLOBAL  Set current global label. See ROM.48S for an example of use	GLOBAL	This_Is_The_Current_Global6.12 INCLUDE  Include the given file. Only one level of include is allowed.	INCLUDE	"A:\SOURCE.48S"6.13 END  Indicate the end of the assembly code.	END7. COMMENTS  Comments are introduced with a semicolon or an asterisk. They end atthe end of the line.* This is a comment; This is also a comment	A=DAT0		; Read value at location D0 and put it in A(A) field **************************************************************************									**			THAT'S ALL FOLK					**									**************************************************************************  This is the end of this brief description of HPDS. In the future, HPDSwill be ported to the MacIntosh and GEM environment. I will try to removesome limitations: character set, 64 bits computing in assembler,...  But for now, just enjoy this version and try many things on you amazingHP48.